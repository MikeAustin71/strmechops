package strmech

import (
	"fmt"
	ePref "github.com/MikeAustin71/errpref"
	"sync"
)

type numStrMathAtom struct {
	lock *sync.Mutex
}

// addRunes - Adds two rune arrays of numeric digits and
// returns the total in a RuneArrayDto instance passed as
// an input parameter.
//
// The computed total of these two rune arrays will be
// expressed as numeric characters returned in a 'total'
// rune array.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	addArray01					*RuneArrayDto
//		A pointer to an instance of RuneArrayDto. This
//		instance contains a rune array of numeric digits
//		which will be added to those contained in input
//		parameter, 'addArray02'.
//
//	addArray02					*RuneArrayDto
//		A pointer to an instance of RuneArrayDto. This
//		instance contains a rune array of numeric digits
//		which will be added to those contained in input
//		parameter, 'addArray01'.
//
//	totalArray 					*RuneArrayDto
//
//		A pointer to an instance of RuneArrayDto. This
//		instance will be populated with the results of
//		the addition operation performed on input
//		parameters 'addArray01' and 'addArray02'.
//
//	extendTotalForCarry			bool
//
//		If this parameter is set to 'true' it signals
//		that carry values from the last add operation
//		will cause the total array to be extended by
//		one array element and populated with a value
//		of one (1).
//
//		If this parameter is set to 'false', a carry
//		value of one (1) generated by the last addition
//		operation will NOT be added to the total array.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string which
//		is included in all returned error messages. Usually,
//		it contains the name of the calling method or methods
//		listed as a function chain.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref' software
//		package, "github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	isCarry 					bool
//
//		If this return parameter is set to 'true', it signals
//		that the last addition operation produced a 'carry'
//		value of '1' which has NOT been added to the total
//		array.
//
//	err							error
//
//		If this method completes successfully, this returned
//		error Type is set equal to 'nil'. If errors are
//		encountered during	processing, the returned error
//		Type will encapsulate an error	message.
//
//		If an error message is returned, the text value for
//		input parameter 'errPrefDto' (error prefix) will be
//		prefixed or attached at the beginning of the error
//		message.
func (nStrMathAtom *numStrMathAtom) addRunes(
	addArray01 *RuneArrayDto,
	addArray02 *RuneArrayDto,
	totalArray *RuneArrayDto,
	extendTotalForCarry bool,
	errPrefDto *ePref.ErrPrefixDto) (
	isCarry bool,
	err error) {

	if nStrMathAtom.lock == nil {
		nStrMathAtom.lock = new(sync.Mutex)
	}

	nStrMathAtom.lock.Lock()

	defer nStrMathAtom.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"numStrMathAtom."+
			"addRunes()",
		"")

	if err != nil {
		return isCarry, err
	}

	if addArray01 == nil {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray01' is "+
			"a nil pointer!\n",
			ePrefix.String())

		return isCarry, err
	}

	if addArray02 == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray02' is "+
			"a nil pointer!\n",
			ePrefix.String())

		return isCarry, err
	}

	if totalArray == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'totalArray' is "+
			"a nil pointer!\n",
			ePrefix.String())

		return isCarry, err
	}

	idxAdd1 := addArray01.GetRuneArrayLength() - 1

	if idxAdd1 < 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray01' is "+
			"a zero length rune array!\n",
			ePrefix.String())

		return isCarry, err
	}

	idxAdd2 := addArray02.GetRuneArrayLength() - 1

	if idxAdd2 < 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray02' is "+
			"a zero length rune array!\n",
			ePrefix.String())

		return isCarry, err
	}

	maxLastIdx := idxAdd1

	if idxAdd2 > maxLastIdx {
		maxLastIdx = idxAdd2
	}

	var num1, num2, factor rune

	isCarry = false

	total := RuneArrayDto{}

	total.charSearchType =
		CharSearchType.LinearTargetStartingIndex()

	total.CharsArray = make([]rune, maxLastIdx+1)

	for i := maxLastIdx; i > -1; i-- {

		if idxAdd1 < 0 {
			num1 = '0'
		} else {
			num1 = addArray01.CharsArray[idxAdd1]
		}

		idxAdd1--

		if idxAdd2 < 0 {
			num2 = '0'
		} else {
			num2 = addArray02.CharsArray[idxAdd2]
		}

		idxAdd2--

		if isCarry {
			factor = 47
			isCarry = false
		} else {
			factor = 48
		}

		total.CharsArray[i] = num1 + num2 - factor

		if total.CharsArray[i] > '9' {
			total.CharsArray[i] -= 10
			isCarry = true
		}

	}

	if isCarry && extendTotalForCarry {

		total.CharsArray = append(
			[]rune{'1'},
			total.CharsArray...)

		isCarry = false

	}

	err = totalArray.CopyIn(
		&total,
		ePrefix.XCpy(
			"totalArray<-total"))

	return isCarry, err
}

// addOneToRunes - Adds a value of one (1) to a series
// of numeric digits contained in a rune array passed
// as an input parameter.
//
// The computed total of these rune array of numeric
// digits plus one (1) will be expressed as numeric
// characters returned in a 'total' rune array.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	addArray					*RuneArrayDto
//		A pointer to an instance of RuneArrayDto. This
//		instance contains a rune array of numeric digits
//		which will be added to a numeric value of one (1).
//
//	totalArray 					*RuneArrayDto
//
//		A pointer to an instance of RuneArrayDto. This
//		instance will be populated with the results of
//		the addition operation performed by adding a
//		value of one (1) to input parameter, 'addArray'.
//
//	extendTotalForCarry			bool
//
//		If this parameter is set to 'true' it signals
//		that carry values from the last add operation
//		will cause the total array to be extended by
//		one array element and populated with a value
//		of one (1).
//
//		If this parameter is set to 'false', a carry
//		value of one (1) generated by the last addition
//		operation will NOT be added to the total array.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string which
//		is included in all returned error messages. Usually,
//		it contains the name of the calling method or methods
//		listed as a function chain.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref' software
//		package, "github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	isCarry 					bool
//
//		If this return parameter is set to 'true', it signals
//		that the last addition operation produced a 'carry'
//		value of '1' which has NOT been added to the total
//		array.
//
//	err							error
//
//		If this method completes successfully, this returned
//		error Type is set equal to 'nil'. If errors are
//		encountered during	processing, the returned error
//		Type will encapsulate an error	message.
//
//		If an error message is returned, the text value for
//		input parameter 'errPrefDto' (error prefix) will be
//		prefixed or attached at the beginning of the error
//		message.
func (nStrMathAtom *numStrMathAtom) addOneToRunes(
	addArray *RuneArrayDto,
	totalArray *RuneArrayDto,
	extendTotalForCarry bool,
	errPrefDto *ePref.ErrPrefixDto) (
	isCarry bool,
	err error) {

	if nStrMathAtom.lock == nil {
		nStrMathAtom.lock = new(sync.Mutex)
	}

	nStrMathAtom.lock.Lock()

	defer nStrMathAtom.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"numStrMathAtom."+
			"addOneToRunes()",
		"")

	if err != nil {
		return isCarry, err
	}

	if addArray == nil {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray' is "+
			"a nil pointer!\n",
			ePrefix.String())

		return isCarry, err
	}

	if totalArray == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'totalArray' is "+
			"a nil pointer!\n",
			ePrefix.String())

		return isCarry, err
	}

	idxAdd1 := addArray.GetRuneArrayLength() - 1

	if idxAdd1 < 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'addArray' is "+
			"a zero length rune array!\n",
			ePrefix.String())

		return isCarry, err
	}

	maxLastIdx := idxAdd1

	var num1, num2, factor rune

	isCarry = false

	total := RuneArrayDto{}

	total.charSearchType =
		CharSearchType.LinearTargetStartingIndex()

	total.CharsArray = make([]rune, maxLastIdx+1)

	for i := maxLastIdx; i > -1; i-- {

		num1 = addArray.CharsArray[idxAdd1]

		if idxAdd1 == maxLastIdx {
			num2 = '1'
		} else {
			num2 = '0'
		}

		idxAdd1--

		if isCarry {
			factor = 47
			isCarry = false
		} else {
			factor = 48
		}

		total.CharsArray[i] = num1 + num2 - factor

		if total.CharsArray[i] > '9' {
			total.CharsArray[i] -= 10
			isCarry = true
		}

	}

	if isCarry && extendTotalForCarry {

		total.CharsArray = append(
			[]rune{'1'},
			total.CharsArray...)

		isCarry = false

	}

	err = totalArray.CopyIn(
		&total,
		ePrefix.XCpy(
			"totalArray<-total"))

	return isCarry, err
}
