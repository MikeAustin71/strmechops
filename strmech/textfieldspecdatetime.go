package strmech

import (
	"fmt"
	ePref "github.com/MikeAustin71/errpref"
	"io"
	"strings"
	"sync"
	"time"
)

// TextFieldSpecDateTime - The Date/Time Text Field specification
// is used to produce a formatted text string from a date/time
// value. The golang date/time types are documented at:
//         https://pkg.go.dev/time
//
// Type TextFieldSpecDateTime is a Text Field Specification. Text
// Field Specifications are designed to be configured as one
// element within a single line of text. That line of text can then
// be used for text displays, file output or printing.
//
// Type TextLineSpecStandardLine can be used to compose a line of
// text consisting of multiple Text Field Specifications like
// TextFieldSpecDateTime. Text Field Specifications like
// TextFieldSpecDateTime are therefore used as the components or
// building blocks for constructing a single lines of text.
//
// For Type TextFieldSpecDateTime, the user will typically supply a
// date time value ('dateTime'), a field length value ('fieldLen'),
// a date time format ('dateTimeFormat') and a text justification
// specification ('textJustification'). Type TextFieldSpecDateTime
// will convert the date time value ('dateTime') to a date time
// string using the format specifications provided in
// 'dateTimeFormat'. Next a text field will be created.
//
// If field length ('fieldLen') is less than the length of the
// computed date time string, the length of the text field will be
// set equal to the length of the date time string. If the field
// length ('fieldLen') is greater than the length of the computed
// date time string, the date time string will be positioned within
// the text field using the text justification specification (left,
// center, right). The justified text field will then be returned to
// the user by calling methods:
//     TextFieldSpecDateTime.GetFormattedText()
//                    or
//     TextFieldSpecDateTime.String()
//
//
// ----------------------------------------------------------------
//
// Member Variables
//
//  dateTime                   time.Time
//     - A valid date/time value which is used to generate a
//       formatted date/time text string. This text string is the
//       content of the text field created by type
//       TextFieldSpecDateTime. Type time.Time is part of the
//       Golang time package:
//            https://pkg.go.dev/time.
//
//
//  fieldLen                   int
//     - The length of the text field in which the formatted
//       'dateTime' value will be displayed.
//
//       If 'fieldLen' is less than the length of the formatted
//       'dateTime' string, it will be automatically set equal to
//       the formatted 'dateTime' string length.
//
//       If 'fieldLen' is greater than the length of the formatted
//       'dateTime' string, 'dateTime' will be positioned within a
//       text field with a length equal to 'fieldLen'. In this
//       case, the position of the 'dateTime' string within the
//       text field will be controlled by the text justification
//       value contained in member variable, 'textJustification'.
//
//
//  dateTimeFormat             string
//     - This string holds the date/time format parameters used to
//       format the 'dateTime' value when generating a 'dateTime'
//       text string. The formatted 'dateTime' text string is
//       generated by type TextFieldSpecDateTime for use in text
//       displays, file output or printing.
//
//       The date/time format parameter is documented in the Golang
//       time.Time package, https://pkg.go.dev/time. The format
//       operations are further documented at
//       https://pkg.go.dev/time#Time.Format.
//
//       If the user configures this parameter as an empty string,
//       'dateTimeFormat' will be assigned a default value of
//       "2006-01-02 15:04:05.000000000 -0700 MST"
//
//       Example Formats:
//        Example 1:
//         dateTimeFormat =
//          "2006-01-02 15:04:05.000000000 -0700 MST"
//        Result =
//          "2021-10-21 14:19:03.000000000 -0500 CDT"
//
//        Example 2:
//         dateTimeFormat =
//          "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//          Result =
//           "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
//
//  textJustification          TextJustify
//     - An enumeration which specifies the justification of the
//       'dateTime' string within a text field with a field length
//       specified by member variable 'fieldLen'.
//
//       Text justification can only be evaluated in the context of
//       a 'dateTime' text string, field length and a
//       'textJustification' object of type TextJustify. This is
//       because a field length ('fieldLen') value equal to or less
//       than the length of the 'dateTime' text string will never
//       use text justification. In these cases, text justification
//       is completely ignored because the length of the text field
//       ('fieldLen') is automatically set equal to the length of
//       the 'dateTime' text string.
//
//       If the field length ('fieldLen') is greater than the
//       length of the 'dateTime' text string, text justification
//       must be equal to one of these three valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
//
// ----------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  Thursday October 21, 2021 14:19:03.000000000 -0500 CDT  "
//
type TextFieldSpecDateTime struct {
	dateTime time.Time // The content of the datetime text.
	fieldLen int       // The length of the text field in which
	//               //  the text label will be positioned.
	dateTimeFormat string // Holds the format parameters used to
	//                        //  format the datetime for text presentation.
	textJustification TextJustify // The specification which controls
	//                            //  how the datetime text will be positioned
	//                            //  within the text field: 'Left', 'Right'
	//                            //  or 'Center'.
	textLineReader *strings.Reader
	lock           *sync.Mutex
}

// CopyIn - Copies the data fields from an incoming instance of
// TextFieldSpecDateTime ('incomingDateTimeTxtField') to the data
// fields of the current TextFieldSpecDateTime instance
// ('txtDateTimeField').
//
// IMPORTANT
// All the data fields in current TextFieldSpecDateTime instance
// ('txtDateTimeField') will be modified and overwritten.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  incomingTxtFieldLabel     *TextFieldSpecDateTime
//     - A pointer to an instance of TextFieldSpecDateTime. This
//       method will NOT change the values of internal member
//       variables contained in this instance.
//
//       All data values in this TextFieldSpecDateTime instance
//       will be copied to current TextFieldSpecDateTime
//       instance ('txtFieldLabel').
//
//       If parameter 'incomingDateTimeTxtField' is determined to be
//       invalid, an error will be returned.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) CopyIn(
	incomingDateTimeTxtField *TextFieldSpecDateTime,
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.CopyIn()",
		"")

	if err != nil {
		return err
	}

	return textFieldSpecDateTimeNanobot{}.ptr().
		copyIn(
			txtDateTimeField,
			incomingDateTimeTxtField,
			ePrefix.XCtx("incomingDateTimeTxtField"))
}

// CopyOut - Returns a deep copy of the current
// TextFieldSpecDateTime instance.
//
// If the current TextFieldSpecDateTime instance is invalid, an
// error will be returned.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  TextFieldSpecDateTime
//     - If this method completes successfully and no errors are
//       encountered, this parameter will return a deep copy of the
//       current TextFieldSpecDateTime instance.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) CopyOut(
	errorPrefix interface{}) (
	TextFieldSpecDateTime, error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.CopyOut()",
		"")

	if err != nil {
		return TextFieldSpecDateTime{}, err
	}

	return textFieldSpecDateTimeNanobot{}.ptr().
		copyOut(
			txtDateTimeField,
			ePrefix.XCtx("txtDateTimeField"))
}

// CopyOutITextField - Returns a deep copy of the current
// TextFieldSpecDateTime instance cast as an ITextFieldSpecification
// object.
//
// If the current TextFieldSpecDateTime instance is invalid, an error
// is returned.
//
// This method is required by the ITextFieldSpecification
// interface.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  ITextFieldSpecification
//     - If this method completes successfully and no errors are
//       encountered, this parameter will return a deep copy of
//       the current TextFieldSpecDateTime instance cast as an
//       ITextFieldSpecification object.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) CopyOutITextField(
	errorPrefix interface{}) (
	ITextFieldSpecification,
	error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	var iTxtFieldSpec ITextFieldSpecification

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.CopyOutITextField()",
		"")

	if err != nil {
		return iTxtFieldSpec, err
	}

	var newTxtDateTimeField TextFieldSpecDateTime

	newTxtDateTimeField,
		err = textFieldSpecDateTimeNanobot{}.ptr().
		copyOut(
			txtDateTimeField,
			ePrefix.XCtx("txtDateTimeField"))

	if err != nil {
		return iTxtFieldSpec, err
	}

	iTxtFieldSpec =
		ITextFieldSpecification(&newTxtDateTimeField)

	return iTxtFieldSpec, nil
}

// CopyOutPtr - Returns a pointer to a deep copy of the current
// TextFieldSpecDateTime instance.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  *TextFieldSpecDateTime
//     - If this method completes successfully and no errors are
//       encountered, this parameter will return a pointer to a
//       deep copy of the current TextFieldSpecDateTime instance.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) CopyOutPtr(
	errorPrefix interface{}) (
	*TextFieldSpecDateTime,
	error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.CopyOutPtr()",
		"")

	if err != nil {
		return &TextFieldSpecDateTime{}, err
	}

	var newTxtDateTimeField TextFieldSpecDateTime

	newTxtDateTimeField,
		err =
		textFieldSpecDateTimeNanobot{}.ptr().
			copyOut(
				txtDateTimeField,
				ePrefix.XCtx("txtDateTimeField"))

	return &newTxtDateTimeField, err
}

// Empty - Resets all internal member variables to their initial
// or zero states.
//
func (txtDateTimeField *TextFieldSpecDateTime) Empty() {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	textFieldSpecDateTimeAtom{}.ptr().empty(
		txtDateTimeField)

	txtDateTimeField.lock.Unlock()

	txtDateTimeField.lock = nil
}

// Equal - Receives a pointer to another instance of
// TextFieldSpecDateTime and proceeds to compare the member
// variables to those of the current TextFieldSpecDateTime instance
// in order to determine if they are equivalent.
//
// A boolean flag showing the result of this comparison is
// returned. If the member variables are equal in all respects,
// this flag is set to 'true'. Otherwise, this method returns
// 'false'.
//
func (txtDateTimeField *TextFieldSpecDateTime) Equal(
	incomingTxtFieldDateTime *TextFieldSpecDateTime) bool {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return textFieldSpecDateTimeAtom{}.ptr().equal(
		txtDateTimeField,
		incomingTxtFieldDateTime)
}

// EqualITextField - Receives an object implementing the
// ITextFieldSpecification interface and proceeds to compare
// the member variables to those of the current
// TextFieldSpecDateTime instance in order to determine if they are
// equivalent.
//
// A boolean flag showing the result of this comparison is
// returned. If the member variables from both instances are equal
// in all respects, this flag is set to 'true'. Otherwise, this
// method returns 'false'.
//
func (txtDateTimeField *TextFieldSpecDateTime) EqualITextField(
	iTextField ITextFieldSpecification) bool {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	if iTextField == nil {
		return false
	}

	dateTimeTxtField, ok := iTextField.(*TextFieldSpecDateTime)

	if !ok {
		return false
	}

	return textFieldSpecDateTimeAtom{}.ptr().equal(
		txtDateTimeField,
		dateTimeTxtField)
}

// GetDateTime - Returns the date/time value encapsulated by the
// current TextFieldSpecDateTime instance.
//
// ------------------------------------------------------------------------
//
// Background
//
// The Date/Time Text Field specification (TextFieldSpecDateTime)
// is used to generate a formatted text string from a date/time
// value.
//
// The golang date/time types are documented at:
//      https://pkg.go.dev/time
//
func (txtDateTimeField *TextFieldSpecDateTime) GetDateTime() time.Time {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return txtDateTimeField.dateTime
}

// GetDateTimeFormat - Returns the date/time format string
// configured for the current instance of TextFieldSpecDateTime.
//
//
// ------------------------------------------------------------------------
//
// Background
//
// The Date/Time Text Field specification (TextFieldSpecDateTime)
// is used to generate a formatted text string from a Date/Time
// value.
//
// The golang date/time types are documented at:
//      https://pkg.go.dev/time
//
// The format string holds the Date/Time format parameters used to
// format the Date/Time value as a Date/Time text string. The
// formatted Date/Time text string is generated by the type
// TextFieldSpecDateTime for use in text displays, file output or
// printing.
//
// The Date/Time format parameter is documented in the Golang
// time.Time package, https://pkg.go.dev/time. The format
// operations are are further documented at
// https://pkg.go.dev/time#Time.Format.
//
// If the user configures this parameter as an empty string,
// 'dateTimeFormat' will be assigned a default
//       value of "2006-01-02 15:04:05.000000000 -0700 MST"
//
func (txtDateTimeField *TextFieldSpecDateTime) GetDateTimeFormat() string {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return txtDateTimeField.dateTimeFormat
}

// GetFieldLength - Returns the length of the text field in which
// the formatted date/time text string will be positioned.
//
// ------------------------------------------------------------------------
//
// Background
//
// Field Length specifies the length of the text field in which the
// formatted date/time text will be displayed.
//
// If Field Length is less than the length of the formatted date/time
// string, it will be automatically set equal to the length of the
// formatted date/time string.
//
// If Field Length is greater than the length of the length of the
// formatted date/time string, the date/time text will be
// positioned within a text field with a length equal to Field
// Length. In this case, the position of the date/time string within
// the text field will be controlled by the text justification
// specification.
//
func (txtDateTimeField *TextFieldSpecDateTime) GetFieldLength() int {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return txtDateTimeField.fieldLen
}

// GetFormattedStrLength - Returns the string length of the
// formatted text generated by the current instance of
// TextFieldSpecDateTime. Effectively, this is the length of the
// strings returned by methods:
//   TextFieldSpecDateTime.GetFormattedText()
//   TextFieldSpecDateTime.String()
//
// If an error is encountered, this method returns a value of minus
// one (-1).
//
func (txtDateTimeField *TextFieldSpecDateTime) GetFormattedStrLength() int {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	ePrefix := ePref.ErrPrefixDto{}.NewEPrefCtx(
		"TextFieldSpecDateTime.GetFormattedStrLength()",
		"")

	formattedTextStr,
		err := textFieldSpecDateTimeNanobot{}.ptr().
		getFormattedText(
			txtDateTimeField,
			ePrefix.XCtx(
				"txtDateTimeField"))

	if err != nil {
		return -1
	}

	return len(formattedTextStr)
}

// GetFormattedText - Returns the formatted text generated by the
// current instance of TextFieldSpecDateTime.
//
// If the length of the Date/Time text string is zero and the field
// length is zero this method returns an empty string.
//
// If the length of the Date/Time text string is zero and the field
// length is greater than zero, this method returns a string with
// a length equal to field length and content equal to white space
// (the space character " " x field length).
//
// If the current instance of TextFieldSpecDateTime is invalid, an
// error will be returned.
//
// This method is similar to method TextFieldSpecDateTime.String()
// with the exception that this method returns an error.
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//                      containing error prefix and error context
//                      information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  string
//     - The formatted text string generated by the current
//       instance of TextFieldSpecDateTime.
//
//
//  error
//     - If the method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  Thursday October 21, 2021 14:19:03.000000000 -0500 CDT  "
//
func (txtDateTimeField *TextFieldSpecDateTime) GetFormattedText(
	errorPrefix interface{}) (
	string,
	error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.GetFormattedText()",
		"")

	if err != nil {
		return "", err
	}

	return textFieldSpecDateTimeNanobot{}.ptr().
		getFormattedText(
			txtDateTimeField,
			ePrefix)
}

// GetTextJustification - Returns the value of the text
// justification specification which will be used to position the
// date/time text string within a text field.
//
// ------------------------------------------------------------------------
//
// Background
//
// The text justification enumeration specification should be set
// to one of three valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
// You can also use the abbreviated text justification enumeration
// syntax as follows:
//
//           TxtJustify.Left()
//           TxtJustify.Right()
//           TxtJustify.Center()
//
// Text justification is only applied when the text field length is
// greater than the length of the formatted date/time text string.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Left()
//
//  Result =
//     "2021-10-10 20:13:34.000000000 -0700 PDT    "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Right()
//
//  Result =
//     "    Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
func (txtDateTimeField *TextFieldSpecDateTime) GetTextJustification() TextJustify {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return txtDateTimeField.textJustification
}

// IsValidInstance - Performs a diagnostic review of the data
// values encapsulated in the current TextFieldSpecDateTime
// instance to determine if they are valid.
//
// If all data element evaluate as valid, this method returns
// 'true'. If any data element is invalid, this method returns
// 'false'.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  --- NONE ---
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  isValid             bool
//     - If all data elements encapsulated by the current instance
//       of TextFieldSpecDateTime are valid, this returned boolean
//       value is set to 'true'. If any data values are invalid,
//       this return parameter is set to 'false'.
//
func (txtDateTimeField *TextFieldSpecDateTime) IsValidInstance() bool {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	isValid,
		_ := textFieldSpecDateTimeAtom{}.ptr().
		isValidTextFieldDateTime(
			txtDateTimeField,
			nil)

	return isValid
}

// IsValidInstanceError - Performs a diagnostic review of the data
// values encapsulated in the current TextFieldSpecDateTime
// instance to determine if they are valid.
//
// If any data element evaluates as invalid, this method will
// return an error.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  errorPrefix         interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If any of the internal member data variables contained in
//       the current instance of TextFieldSpecDateTime are found to be
//       invalid, this method will return an error.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' (error prefix) will be inserted or
//       prefixed at the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) IsValidInstanceError(
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.IsValidInstanceError()",
		"")

	if err != nil {
		return err
	}

	_,
		err = textFieldSpecDateTimeAtom{}.ptr().
		isValidTextFieldDateTime(
			txtDateTimeField,
			ePrefix.XCtx(
				"txtDateTimeField"))

	return err
}

// New - Returns a new concrete instance of TextFieldSpecDateTime.
// This returned instance is empty and unpopulated. All the member
// variables contained in this new instance are set to their
// uninitialized or zero values.
//
// The returned instance of TextFieldSpecDateTime serves as a Text
// Field Specification. Text Field Specifications are designed to
// be configured within a single line of text. That line of text
// can then be used for text displays, file output or printing.
//
// Type TextLineSpecStandardLine can be used to compose a line of
// text consisting of multiple Text Field Specifications like
// TextFieldSpecDateTime. Text Field Specifications like
// TextFieldSpecDateTime are therefore used as the components or
// building blocks for constructing a single lines of text.
//
// Be advised that setting member variables of the returned
// TextFieldSpecDateTime instance to their zero values means that
// the returned instance is invalid. Therefore, in order to use
// this TextFieldSpecDateTime instance, users must later call the
// setter methods on this type in order to configure valid and
// meaningful meaningful member variable data values.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  --- NONE ---
//
//
// -----------------------------------------------------------------
//
// Return Values
//
//  TextFieldSpecDateTime
//     - This parameter returns a new and empty concrete instance
//       of TextFieldSpecDateTime. Member variable data values are
//       set to their initial or zero values.
//
func (txtDateTimeField TextFieldSpecDateTime) New() TextFieldSpecDateTime {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	newTxtFieldDateTime := TextFieldSpecDateTime{}

	newTxtFieldDateTime.textJustification = TextJustify(0).None()

	newTxtFieldDateTime.textLineReader = nil

	newTxtFieldDateTime.lock = new(sync.Mutex)

	return newTxtFieldDateTime
}

// NewPtr - Returns a pointer to a new unpopulated instance of
// TextFieldSpecDateTime. All the member variables contained in
// this new instance are set to their uninitialized or zero values.
//
// Be advised that setting member variables to their zero values
// means that the returned TextFieldSpecDateTime instance is
// invalid. Therefore, in order to use this TextFieldSpecDateTime
// instance, users must later call the setter methods on this type
// in order to configure valid and meaningful member variable data
// values.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  --- NONE ---
//
//
// -----------------------------------------------------------------
//
// Return Values
//
//  *TextFieldSpecDateTime
//     - This parameter returns a pointer to a new, empty instance
//       of TextFieldSpecDateTime. Member variable data values are
//       set to their initial or zero values.
//
func (txtDateTimeField TextFieldSpecDateTime) NewPtr() *TextFieldSpecDateTime {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	newTxtFieldDateTime := TextFieldSpecDateTime{}

	newTxtFieldDateTime.textJustification = TextJustify(0).None()

	newTxtFieldDateTime.textLineReader = nil

	newTxtFieldDateTime.lock = new(sync.Mutex)

	return &newTxtFieldDateTime
}

// NewDateTimeField - Returns a new, populated, concrete instance
// of TextFieldSpecDateTime. This type encapsulates a date time
// value which is formatted as a text string.
//
// The new returned instance of TextFieldSpecDateTime is
// constructed from input parameters, 'dateTime', 'fieldLen',
// 'dateTimeFormat' and 'textJustification'.
//
// This method is identical to
// TextFieldSpecDateTime.NewPtrDateTimeField() with the sole
// exception being that this method returns a concrete instance of
// TextFieldSpecDateTime and
// TextFieldSpecDateTime.NewPtrDateTimeField() returns a pointer to
// a TextFieldSpecDateTime instance.
//
//
// ------------------------------------------------------------------------
//
// Background
//
// Type TextFieldSpecDateTime is a Text Field Specification. Text
// Field Specifications are designed to be configured as one
// element within a single line of text. That line of text can then
// be used for text displays, file output or printing.
//
// Type TextLineSpecStandardLine can be used to compose a line of
// text consisting of multiple Text Field Specifications like
// TextFieldSpecDateTime. Text Field Specifications like
// TextFieldSpecDateTime are therefore used as the components or
// building blocks for constructing a single lines of text.
//
// For Type TextFieldSpecDateTime, the user will typically supply a
// date time value ('dateTime'), a field length value ('fieldLen'),
// a date time format ('dateTimeFormat') and a text justification
// specification ('textJustification'). Type TextFieldSpecDateTime
// will convert the date time value ('dateTime') to a date time
// string using the format specifications provided in
// 'dateTimeFormat'. Next a text field will be created.
//
// If field length ('fieldLen') is less than the length of the
// computed date time string, the length of the text field will be
// set equal to the length of the date time string. If the field
// length ('fieldLen') is greater than the length of the computed
// date time string, the date time string will be positioned within
// the text field using the text justification specification (left,
// center, right). The justified text field will then be returned to
// the user by calling methods:
//     TextFieldSpecDateTime.GetFormattedText()
//                    or
//     TextFieldSpecDateTime.String()
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  dateTime                   time.Time
//     - A valid date time value which is used to generate a
//       formatted Date/Time text string. Type time.Time is part of
//       the Golang time package:
//              https://pkg.go.dev/time.
//
//       If this parameter is submitted as a zero value, an error
//       will be returned.
//
//
//  fieldLen                   int
//     - The length of the text field in which the formatted
//       'dateTime' value will be displayed.
//
//       If 'fieldLen' is less than the length of the formatted
//       'dateTime' string, it will be automatically set equal to
//       the formatted 'dateTime' string length.
//
//       If 'fieldLen' is greater than the length of the formatted
//       'dateTime' string, 'dateTime' will be positioned within a
//       text field with a length equal to 'fieldLen'. In this
//       case, the position of the 'dateTime' string within the
//       text field will be controlled by the text justification
//       value contained in parameter, 'textJustification'.
//
//       To automatically set the value of 'fieldLen' to the length
//       of the formatted 'dateTime', set this parameter to a value
//       of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  dateTimeFormat             string
//     - This string holds the Date/Time format parameters used to
//       format the 'dateTime' value when generating a 'dateTime'
//       text string. The formatted 'dateTime' text string is
//       generated by type TextFieldSpecDateTime for use in text
//       displays, file output or printing.
//
//       The Date/Time format is documented in the Golang time.Time
//       package, https://pkg.go.dev/time. The format operations
//       are documented at https://pkg.go.dev/time#Time.Format .
//
//       If this parameter is submitted as an empty string,
//       parameter 'dateTimeFormat' will be assigned a default
//       value of "2006-01-02 15:04:05.000000000 -0700 MST".
//
//       Example Formats:
//        Example 1:
//         dateTimeFormat =
//          "2006-01-02 15:04:05.000000000 -0700 MST"
//        Result =
//          "2021-10-21 14:19:03.000000000 -0500 CDT"
//
//        Example 2:
//         dateTimeFormat =
//          "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//          Result =
//           "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
//
//  textJustification          TextJustify
//     - An enumeration which specifies the justification of the
//       'dateTime' string within a text field with a field length
//       specified by parameter 'fieldLen'.
//
//       Text justification can only be evaluated in the context of
//       a 'dateTime' text string, field length and a
//       'textJustification' object of type TextJustify. This is
//       because a field length ('fieldLen') value equal to or less
//       than the length of the 'dateTime' text string will never
//       use text justification. In these cases, text justification
//       is completely ignored because the length of the text field
//       ('fieldLen') is automatically set equal to the length of
//       the 'dateTime' text string.
//
//       If the field length is greater than the length of the text
//       label, text justification must be equal to one of these
//       three valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
//       You can also use the abbreviated text justification
//       enumeration syntax as follows:
//
//           TxtJustify.Left()
//           TxtJustify.Right()
//           TxtJustify.Center()
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newTextDateTime            *TextFieldSpecDateTime
//     - This method will return a new, populated concrete instance
//       of TextFieldSpecDateTime constructed from the information
//       provided by the input parameters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  Thursday October 21, 2021 14:19:03.000000000 -0500 CDT  "
//
func (txtDateTimeField TextFieldSpecDateTime) NewDateTimeField(
	dateTime time.Time,
	fieldLen int,
	dateTimeFormat string,
	textJustification TextJustify,
	errorPrefix interface{}) (
	newTextDateTime TextFieldSpecDateTime,
	err error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.NewDateTimeField()",
		"")

	if err != nil {
		return newTextDateTime, err
	}

	err = textFieldSpecDateTimeMechanics{}.ptr().
		setTextFieldDateTime(
			&newTextDateTime,
			dateTime,
			fieldLen,
			dateTimeFormat,
			textJustification,
			ePrefix)

	return newTextDateTime, err
}

// NewPtrDateTimeField - Returns a pointer to a new, fully
// populated, instance of TextFieldSpecDateTime. This type
// encapsulates a date time value which is formatted as a text
// string.
//
// The new returned instance of TextFieldSpecDateTime is
// constructed from input parameters, 'dateTime', 'fieldLen',
// 'dateTimeFormat' and 'textJustification'.
//
// This method is identical to
// TextFieldSpecDateTime.NewDateTimeField() with the sole exception
// being that this method returns a pointer to an instance of
// TextFieldSpecDateTime and
// TextFieldSpecDateTime.NewDateTimeField() returns a concrete
// instance of TextFieldSpecDateTime.
//
//
// ------------------------------------------------------------------------
//
// Background
//
// Type TextFieldSpecDateTime is a Text Field Specification. Text
// Field Specifications are designed to be configured as one
// element within a single line of text. That line of text can then
// be used for text displays, file output or printing.
//
// Type TextLineSpecStandardLine can be used to compose a line of
// text consisting of multiple Text Field Specifications like
// TextFieldSpecDateTime. Text Field Specifications like
// TextFieldSpecDateTime are therefore used as the components or
// building blocks for constructing a single lines of text.
//
// For Type TextFieldSpecDateTime, the user will typically supply a
// date time value ('dateTime'), a field length value ('fieldLen'),
// a date time format ('dateTimeFormat') and a text justification
// specification ('textJustification'). Type TextFieldSpecDateTime
// will convert the date time value ('dateTime') to a date time
// string using the format specifications provided in
// 'dateTimeFormat'. Next a text field will be created.
//
// If field length ('fieldLen') is less than the length of the
// computed date time string, the length of the text field will be
// set equal to the length of the date time string. If the field
// length ('fieldLen') is greater than the length of the computed
// date time string, the date time string will be positioned within
// the text field using the text justification specification (left,
// center, right). The justified text field will then be returned to
// the user by calling methods:
//     TextFieldSpecDateTime.GetFormattedText()
//                    or
//     TextFieldSpecDateTime.String()
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  dateTime                   time.Time
//     - A valid date time value which is used to generate a
//       formatted date/time text string. Type time.Time is part of
//       the Golang time package:
//              https://pkg.go.dev/time.
//
//       If this parameter is submitted as a zero value, an error
//       will be returned.
//
//
//  fieldLen                   int
//     - The length of the text field in which the formatted
//       'dateTime' value will be displayed.
//
//       If 'fieldLen' is less than the length of the formatted
//       'dateTime' string, it will be automatically set equal to
//       the formatted 'dateTime' string length.
//
//       If 'fieldLen' is greater than the length of the formatted
//       'dateTime' string, 'dateTime' will be positioned within a
//       text field with a length equal to 'fieldLen'. In this
//       case, the position of the 'dateTime' string within the
//       text field will be controlled by the text justification
//       value contained in parameter, 'textJustification'.
//
//       To automatically set the value of 'fieldLen' to the length
//       of the formatted 'dateTime', set this parameter to a value
//       of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  dateTimeFormat             string
//     - This string holds the date/time format parameters used to
//       format the 'dateTime' value when generating a 'dateTime'
//       text string. The formatted 'dateTime' text string is
//       generated by type TextFieldSpecDateTime for use in text
//       displays, file output or printing.
//
//       The date/time format is documented in the Golang time.Time
//       package, https://pkg.go.dev/time. The format operations are
//       are documented at https://pkg.go.dev/time#Time.Format .
//
//       If this parameter is submitted as an empty string,
//       parameter 'dateTimeFormat' will be assigned a default
//       value of "2006-01-02 15:04:05.000000000 -0700 MST".
//
//       Example Formats:
//        Example 1:
//         dateTimeFormat =
//          "2006-01-02 15:04:05.000000000 -0700 MST"
//        Result =
//          "2021-10-21 14:19:03.000000000 -0500 CDT"
//
//        Example 2:
//         dateTimeFormat =
//          "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//          Result =
//           "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
//
//  textJustification          TextJustify
//     - An enumeration which specifies the justification of the
//       'dateTime' string within a text field with a field length
//       specified by parameter 'fieldLen'.
//
//       Text justification can only be evaluated in the context of
//       a 'dateTime' text string, field length and a
//       'textJustification' object of type TextJustify. This is
//       because a field length ('fieldLen') value equal to or less
//       than the length of the 'dateTime' text string will never
//       use text justification. In these cases, text justification
//       is completely ignored because the length of the text field
//       ('fieldLen') is automatically set equal to the length of
//       the 'dateTime' text string.
//
//       If the field length is greater than the length of the text
//       label, text justification must be equal to one of these
//       three valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
//       You can also use the abbreviated text justification
//       enumeration syntax as follows:
//
//           TxtJustify.Left()
//           TxtJustify.Right()
//           TxtJustify.Center()
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  newTextDateTime            TextFieldSpecDateTime
//     - This method will return a new, populated concrete instance
//       of TextFieldSpecDateTime constructed from the information
//       provided by the input parameters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  Thursday October 21, 2021 14:19:03.000000000 -0500 CDT  "
//
func (txtDateTimeField TextFieldSpecDateTime) NewPtrDateTimeField(
	dateTime time.Time,
	fieldLen int,
	dateTimeFormat string,
	textJustification TextJustify,
	errorPrefix interface{}) (
	newTextDateTime *TextFieldSpecDateTime,
	err error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	newTextDateTime = TextFieldSpecDateTime{}.NewPtr()

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.NewDateTimeField()",
		"")

	if err != nil {
		return newTextDateTime, err
	}

	err = textFieldSpecDateTimeMechanics{}.ptr().
		setTextFieldDateTime(
			newTextDateTime,
			dateTime,
			fieldLen,
			dateTimeFormat,
			textJustification,
			ePrefix)

	return newTextDateTime, err
}

// Read - Implements the io.Reader interface for type
// TextFieldSpecDateTime.
//
// The formatted text string generated by the current instance of
// TextFieldSpecDateTime will be written to the byte buffer 'p'. If
// the length of 'p' is less than the length of the formatted text
// string, multiple calls to this method will write the remaining
// unread characters to the byte buffer 'p'.
//
// Read() supports buffered 'read' operations.
//
// This method reads up to len(p) bytes into p. It returns the
// number of bytes read (0 <= n <= len(p)) and any error
// encountered. Even if read returns n < len(p), it may use all
// of p as scratch space during the call.
//
// If some data is available but not len(p) bytes, readBytes()
// conventionally returns what is available instead of waiting
// for more.
//
// When this method encounters an error or end-of-file condition
// after successfully reading n > 0 bytes, it returns the number
// of bytes read. It may return the (non-nil) error from the same
// call or return the error (and n == 0) from a subsequent call.
// An instance of this general case is that a Reader returning
// a non-zero number of bytes at the end of the input stream may
// return either err == EOF or err == nil. The next read operation
// should return 0, EOF.
//
// Callers should always process the n > 0 bytes returned before
// considering the error err. Doing so correctly handles I/O errors
// that happen after reading some bytes and also both of the
// allowed EOF behaviors.
//
// The last read operation performed on the formatted text string
// will always return n==0 and err==io.EOF.
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  p                          []byte
//     - The byte buffer into which the formatted text string
//       generated by the current txtFillerField instance will be
//       written.
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  n                          int
//     - The number of bytes written to byte buffer 'p'.
//
//       Read() reads up to len(p) bytes into p. It returns
//       the number of bytes read (0 <= n <= len(p)) and any error
//       encountered. Even if Read() returns n < len(p), it may use
//       all of 'p' as scratch space during the call. If some
//       data is available but not len(p) bytes, Read()
//       conventionally returns what is available instead of
//       waiting for more.
//
//
//  err                        error
//     - If this method completes successfully, this returned error
//       Type is set equal to 'nil'. If errors are encountered
//       during processing, the returned error Type will
//       encapsulate an error message.
//
//       When Read() encounters an error or end-of-file condition
//       after successfully reading n > 0 bytes, it returns the
//       number of bytes read. It may return the (non-nil) error
//       from the same call or return the error (and n == 0) from
//       a subsequent call. An instance of this general case is
//       that a Reader returning a non-zero number of bytes at the
//       end of the input stream may return either err == EOF or
//       err == nil. The next read operation should return 0, EOF.
//
//
// ------------------------------------------------------------------------
//
// Usage Examples:
//
//  Example # 1
//
//  p := make([]byte, 50)
//
//  var n, readBytesCnt int
//  sb := strings.Builder{}
//
//  for {
//
//    n,
//    err = txtDateTimeField01.Read(p)
//
//    if n == 0 {
//      break
//    }
//
//    sb.Write(p[:n])
//    readBytesCnt += n
//  }
//
//  if err != nil &&
//    err != io.EOF {
//     return fmt.Errorf(
//      "Error Returned From txtDateTimeField01.Read(p)\n"+
//      "Error = \n%v\n",
//       err.Error())
//  }
//
//  fmt.Printf("Text Line String: %s\n",
//                sb.String())
//
//  fmt.Printf("Number of bytes Read: %v\n",
//                readBytesCnt)
//
//  Example # 2
//
//  p := make([]byte, 50)
//
//  var n, readBytesCnt int
//  var actualStr string
//
//  for {
//
//    n,
//    err = txtDateTimeField01.Read(p)
//
//    if n == 0 {
//      break
//    }
//
//    actualStr += string(p[:n])
//    readBytesCnt += n
//  }
//
//  if err != nil &&
//    err != io.EOF {
//     return fmt.Errorf(
//      "Error Returned From txtDateTimeField01.Read(p)\n"+
//      "Error = \n%v\n",
//       err.Error())
//  }
//
//  fmt.Printf("Text Line String: %v\n",
//                actualStr)
//
//  fmt.Printf("Number of bytes Read: %v\n",
//                readBytesCnt)
//
func (txtDateTimeField *TextFieldSpecDateTime) Read(
	p []byte) (
	n int,
	err error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	ePrefix := ePref.ErrPrefixDto{}.NewEPrefCtx(
		"TextFieldSpecDateTime.Read()",
		"")

	if txtDateTimeField.textLineReader == nil {

		var formattedText string

		formattedText,
			err =
			textFieldSpecDateTimeNanobot{}.ptr().
				getFormattedText(
					txtDateTimeField,
					ePrefix.XCtx(
						"txtDateTimeField"))

		if err != nil {
			return n, err
		}

		txtDateTimeField.textLineReader =
			strings.NewReader(formattedText)

		if txtDateTimeField.textLineReader == nil {
			err = fmt.Errorf("%v\n"+
				"Error: strings.NewReader(formattedText)\n"+
				"returned a nil pointer.\n"+
				"txtDateTimeField.textLineReader == nil\n",
				ePrefix.XCtxEmpty().String())

			return n, err
		}
	}

	n,
		err = textSpecificationAtom{}.ptr().
		readBytes(
			txtDateTimeField.textLineReader,
			p,
			ePrefix.XCtx(
				"p -> txtDateTimeField.textLineReader"))

	if err == io.EOF {

		txtDateTimeField.textLineReader = nil

	}

	return n, err
}

// ReaderInitialize - This method will reset the internal member
// variable 'TextFieldSpecDateTime.textLineReader' to its initial
// zero state of 'nil'. Effectively, this resets the internal
// strings.Reader object for use in future read operations.
//
// This method is rarely used or needed. It provides a means of
// reinitializing the internal strings.Reader object in case an
// error occurs during a read operation initiated by method
// TextFieldSpecDateTime.Read().
//
// Calling this method cleans up the residue from an aborted read
// operation and prepares the strings.Reader object for future read
// operations.
//
// If any errors are returned by method
// TextFieldSpecDateTime.Read() which are NOT equal to io.EOF, call
// this method, TextFieldSpecDateTime.ReaderInitialize(), to reset
// and prepare the internal reader for future read operations.
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
func (txtDateTimeField *TextFieldSpecDateTime) ReaderInitialize() {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	txtDateTimeField.textLineReader = nil

	return
}

// SetDateTimeFieldSpec - Sets the date time text field component
// values for the current instance of TextFieldSpecDateTime.
//
// IMPORTANT
//
// This method will overwrite and delete the existing data values
// for the current TextFieldSpecDateTime instance
// (txtDateTimeField).
//
//
// ------------------------------------------------------------------------
//
// Background
//
// Type TextFieldSpecDateTime is a Text Field Specification. Text
// Field Specifications are designed to be configured as one
// element within a single line of text. That line of text can then
// be used for text displays, file output or printing.
//
// Type TextLineSpecStandardLine can be used to compose a line of
// text consisting of multiple Text Field Specifications like
// TextFieldSpecDateTime. Text Field Specifications like
// TextFieldSpecDateTime are therefore used as the components or
// building blocks for constructing a single lines of text.
//
// For Type TextFieldSpecDateTime, the user will typically supply a
// date time value ('dateTime'), a field length value ('fieldLen'),
// a date time format ('dateTimeFormat') and a text justification
// specification ('textJustification'). Type TextFieldSpecDateTime
// will convert the date time value ('dateTime') to a date time
// string using the format specifications provided in
// 'dateTimeFormat'. Next a text field will be created.
//
// If field length ('fieldLen') is less than the length of the
// computed date time string, the length of the text field will be
// set equal to the length of the date time string. If the field
// length ('fieldLen') is greater than the length of the computed
// date time string, the date time string will be positioned within
// the text field using the text justification specification (left,
// center, right). The justified text field will then be returned to
// the user by calling methods:
//     TextFieldSpecDateTime.GetFormattedText()
//                    or
//     TextFieldSpecDateTime.String()
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  dateTime                   time.Time
//     - A valid date time value which is used to generate a
//       formatted date/time text string. Type time.Time is part of
//       the Golang time package:
//              https://pkg.go.dev/time.
//
//       If this parameter is submitted as a zero value, an error
//       will be returned.
//
//
//  fieldLen                   int
//     - The length of the text field in which the formatted
//       'dateTime' value will be displayed.
//
//       If 'fieldLen' is less than the length of the formatted
//       'dateTime' string, it will be automatically set equal to
//       the formatted 'dateTime' string length.
//
//       If 'fieldLen' is greater than the length of the formatted
//       'dateTime' string, 'dateTime' will be positioned within a
//       text field with a length equal to 'fieldLen'. In this
//       case, the position of the 'dateTime' string within the
//       text field will be controlled by the text justification
//       value contained in parameter, 'textJustification'.
//
//       To automatically set the value of 'fieldLen' to the length
//       of the formatted 'dateTime', set this parameter to a value
//       of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  dateTimeFormat             string
//     - This string holds the date/time format parameters used to
//       format the 'dateTime' value when generating a 'dateTime'
//       text string. The formatted 'dateTime' text string is
//       generated by type TextFieldSpecDateTime for use in text
//       displays, file output or printing.
//
//       The date/time format is documented in the Golang time.Time
//       package, https://pkg.go.dev/time. The format operations are
//       are documented at https://pkg.go.dev/time#Time.Format .
//
//       If this parameter is submitted as an empty string,
//       parameter 'dateTimeFormat' will be assigned a default
//       value of "2006-01-02 15:04:05.000000000 -0700 MST".
//
//       Example Formats:
//        Example 1:
//         dateTimeFormat =
//          "2006-01-02 15:04:05.000000000 -0700 MST"
//        Result =
//          "2021-10-21 14:19:03.000000000 -0500 CDT"
//
//        Example 2:
//         dateTimeFormat =
//          "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//          Result =
//           "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
//
//  textJustification          TextJustify
//     - An enumeration which specifies the justification of the
//       'dateTime' string within a text field with a field length
//       specified by parameter 'fieldLen'.
//
//       Text justification can only be evaluated in the context of
//       a 'dateTime' text string, field length and a
//       'textJustification' object of type TextJustify. This is
//       because a field length ('fieldLen') value equal to or less
//       than the length of the 'dateTime' text string will never
//       use text justification. In these cases, text justification
//       is completely ignored because the length of the text field
//       ('fieldLen') is automatically set equal to the length of
//       the 'dateTime' text string.
//
//       If the field length is greater than the length of the text
//       label, text justification must be equal to one of these
//       three valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
//       You can also use the abbreviated text justification
//       enumeration syntax as follows:
//
//           TxtJustify.Left()
//           TxtJustify.Right()
//           TxtJustify.Center()
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 52 + 6
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  Thursday October 21, 2021 14:19:03.000000000 -0500 CDT  "
//
func (txtDateTimeField *TextFieldSpecDateTime) SetDateTimeFieldSpec(
	dateTime time.Time,
	fieldLen int,
	dateTimeFormat string,
	textJustification TextJustify,
	errorPrefix interface{}) (
	err error) {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.SetDateTimeFieldSpec()",
		"")

	if err != nil {
		return err
	}

	err = textFieldSpecDateTimeMechanics{}.ptr().
		setTextFieldDateTime(
			txtDateTimeField,
			dateTime,
			fieldLen,
			dateTimeFormat,
			textJustification,
			ePrefix)

	return err
}

// SetDateTimeFormat - Sets the Date/Time format parameter for the
// current instance of TextFieldSpecDateTime.
//
// The Date/Time format string holds format parameters used to
// convert the Date/Time value to a text string. The formatted
// Date/Time text string is generated by type TextFieldSpecDateTime for use in text
// displays, file output or printing.
//
// The Date/Time format is documented in the Golang time.Time
// package, https://pkg.go.dev/time. The format operations are
// documented at https://pkg.go.dev/time#Time.Format .
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  dateTimeFormat             string
//     - This string holds the Date/Time format parameters used to
//       format the 'dateTime' value when generating a Date/Time
//       text string. The formatted Date/Time text string is
//       generated by type TextFieldSpecDateTime for use in text
//       displays, file output or printing.
//
//       If this parameter is submitted as an empty string,
//       parameter 'dateTimeFormat' will be assigned a default
//       value of "2006-01-02 15:04:05.000000000 -0700 MST".
//
//       Example Formats:
//        Example 1:
//         dateTimeFormat =
//          "2006-01-02 15:04:05.000000000 -0700 MST"
//        Result =
//          "2021-10-21 14:19:03.000000000 -0500 CDT"
//
//        Example 2:
//         dateTimeFormat =
//          "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//          Result =
//           "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) SetDateTimeFormat(
	dateTimeFormat string,
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.SetDateTimeFormat()",
		"")

	if err != nil {
		return err
	}

	if len(dateTimeFormat) == 0 {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'dateTimeFormat' is an empty string!\n",
			ePrefix.String())

		return err
	}

	txtDateTimeField.dateTimeFormat =
		dateTimeFormat

	return nil
}

// SetDateTimeValue - Sets the Date/Time value for the current
// instance of TextFieldSpecDateTime.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  dateTime                   time.Time
//     - A valid date time value which is used to generate a
//       formatted date/time text string. Type time.Time is part of
//       the Golang time package:
//              https://pkg.go.dev/time.
//
//       If this parameter is submitted as a zero value, an error
//       will be returned.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) SetDateTimeValue(
	dateTime time.Time,
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.SetFieldLength()",
		"")

	if err != nil {
		return err
	}

	if dateTime.IsZero() {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'dateTime' has a ZERO value!\n",
			ePrefix.String())

		return err
	}

	txtDateTimeField.dateTime = dateTime

	return nil
}

// SetFieldLength - Sets The length of the text field in which the
// text label string will be positioned for text display, file
// output or printing.
//
// ------------------------------------------------------------------------
//
// Background
//
// Field Length specifies the length of the text field in which the
// formatted date/time text will be displayed.
//
// If Field Length is less than the length of the formatted date/time
// string, it will be automatically set equal to the length of the
// formatted date/time string.
//
// If Field Length is greater than the length of the length of the
// formatted date/time string, the date/time text will be
// positioned within a text field with a length equal to Field
// Length. In this case, the position of the date/time string within
// the text field will be controlled by the text justification
// specification.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  fieldLen                   int
//     - The length of the text field in which the 'textLabelChars'
//       will be displayed. If 'fieldLen' is less than the length
//       of the 'textLabelChars' array, it will be automatically
//       set equal to the 'textLabelChars' array length.
//
//       To automatically set the value of 'fieldLen' to the length
//       of 'textLabelChars', set this parameter to a value of
//       minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1), an error will be returned.
//
//       If 'fieldLen' is submitted with a value greater than
//       1-million (1,000,000), an error will be returned.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Input Parameters
//
//  fieldLen                   int
//     - The length of the text field in which the Date/Time text
//       string will be displayed. If 'fieldLen' is less than the
//       length of the Date/Time text string, it will be
//       automatically set equal to the length of the Date/Time
//       text string.
//
//       To automatically set the value of 'fieldLen' to the length
//       of the Date/Time text string, set this parameter to a
//       value of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1), an error will be returned.
//
//       If 'fieldLen' is submitted with a value greater than
//       1-million (1,000,000), an error will be returned.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//
//  dateTimeFormat =
//     "2006-01-02 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
//
//  Example 3:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = -1
//
//  dateTimeFormat =
//     "Monday January 2, 2006 15:04:05.000000000 -0700 MST"
//
//  textJustification = TxtJustify.Center()
//
//  Result =
//     "Thursday October 21, 2021 14:19:03.000000000 -0500 CDT"
//
func (txtDateTimeField *TextFieldSpecDateTime) SetFieldLength(
	fieldLen int,
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.SetFieldLength()",
		"")

	if err != nil {
		return err
	}

	err =
		textFieldSpecLabelElectron{}.ptr().
			isFieldLengthValid(
				fieldLen,
				ePrefix.XCtx(
					"'fieldLen' Invalid!"))

	if err != nil {
		return err
	}

	txtDateTimeField.fieldLen = fieldLen

	return nil
}

// String - Returns the formatted text generated by the
// current instance of TextFieldSpecDateTime.
//
// If the length of the text label string is zero and the field
// length is zero this method returns an empty string.
//
// If the length of the text label string is zero and the field
// length is greater than zero, this method returns a string with
// a length equal to field length and content equal to white space
// (the space character " " x field length).
//
// This method is identical in function to
// TextFieldSpecDateTime.GetFormattedText()
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
// This method also fulfills the requirements of the 'Stringer'
// interface defined in the Golang package 'fmt'. Reference:
//   https://pkg.go.dev/fmt#Stringer
//
//
// ------------------------------------------------------------------------
//
// Example Usage
//
//  Example 1:
//
//  // dateTime = October 21, 2021 14:19:03-hours
//  // Time Zone = "America/Chicago"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       21,
//       14,
//       19,
//       3,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//  dateTimeFormat = "2006-01-02 15:04:05.000000000 -0700 MST"
//  textJustification = TxtJustify.Center()
//
//  Result = "  2021-10-21 14:19:03.000000000 -0500 CDT  "
//
//
//  Example 2:
//
//  // dateTime = October 10, 2021 20:13:34-hours
//  // Time Zone = "America/Los_Angeles"
//    dateTime = time.Date(
//       2021,
//       time.Month(10),
//       10,
//       20,
//       13,
//       34,
//       0,
//       tzLocPtr)
//
//  fieldLen = 39 + 4
//  dateTimeFormat = "2006-01-02 15:04:05.000000000 -0700 MST"
//  textJustification = TxtJustify.Center()
//
//  Result = "  2021-10-10 20:13:34.000000000 -0700 PDT  "
//
func (txtDateTimeField *TextFieldSpecDateTime) String() string {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	ePrefix := ePref.ErrPrefixDto{}.NewEPrefCtx(
		"TextFieldSpecDateTime.String()",
		"")

	result,
		err := textFieldSpecDateTimeNanobot{}.ptr().
		getFormattedText(
			txtDateTimeField,
			ePrefix.XCtx(
				"txtDateTimeField"))

	if err != nil {
		result = fmt.Sprintf("%v",
			err.Error())
	}

	return result
}

// TextBuilder - Configures the line of text produced by this
// instance of TextFieldSpecDateTime, and writes it to an instance
// of strings.Builder.
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  sBuilder                   *strings.Builder
//    - A pointer to an instance of strings.Builder. The line of
//      text produced by the current instance of
//      TextFieldSpecDateTime and writes that text to 'sBuilder'.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this parameter
//       to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings containing
//                      error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of ErrPrefixDto.
//                          ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package, "github.com/MikeAustin71/errpref".
//
//
// ------------------------------------------------------------------------
//
// Return Values
//
//  error
//     - If the method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtDateTimeField *TextFieldSpecDateTime) TextBuilder(
	sBuilder *strings.Builder,
	errorPrefix interface{}) error {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldSpecDateTime.TextBuilder()",
		"")

	if err != nil {
		return err
	}

	if sBuilder == nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'sBuilder' (strings.Builder)\n"+
			"is invalid! 'sBuilder' is a 'nil' pointer.\n",
			ePrefix.String())

		return err
	}

	var formattedTxtStr string

	formattedTxtStr,
		err = textFieldSpecDateTimeNanobot{}.ptr().
		getFormattedText(
			txtDateTimeField,
			ePrefix.XCtx(
				"txtDateTimeField"))

	if err != nil {
		return err
	}

	var err2 error

	_,
		err2 = sBuilder.WriteString(formattedTxtStr)

	if err2 != nil {
		err = fmt.Errorf("%v\n"+
			"Error returned by sBuilder.WriteString(formattedTxtStr)\n"+
			"%v\n",
			ePrefix.XCtxEmpty().String(),
			err2.Error())
	}

	return err
}

// TextFieldName - returns a string specifying the name of the Text
// Field specification.
//
// This method fulfills the requirements of the
// ITextFieldSpecification interface.
//
func (txtDateTimeField *TextFieldSpecDateTime) TextFieldName() string {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return "TextFieldSpecDateTime"
}

// TextTypeName - returns a string specifying the type of Text
// Field specification.
//
// This method fulfills the requirements of the ITextSpecification
// interface.
//
func (txtDateTimeField *TextFieldSpecDateTime) TextTypeName() string {

	if txtDateTimeField.lock == nil {
		txtDateTimeField.lock = new(sync.Mutex)
	}

	txtDateTimeField.lock.Lock()

	defer txtDateTimeField.lock.Unlock()

	return "TextFieldSpecDateTime"
}
