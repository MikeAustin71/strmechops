package strmech

import (
	"fmt"
	ePref "github.com/MikeAustin71/errpref"
	"strings"
	"sync"
	"time"
)

// TextStrBuilder - The Text String Builder generates formatted
// text character strings for text displays, file output or
// printing.
//
// 'TextStrBuilder' methods are designed to receive a pointer to an
// instances of strings.Builder from the calling function. This
// instance of strings.Builder is used store the formatted text
// generated by individual 'TextStrBuilder' methods.
//
// The 'TextStrBuilder' methods will produce formatted text
// string elements. These text elements may consist of a single
// text field, a series of text fields or an entire line of text
// depending on the method invoked.
//
type TextStrBuilder struct {
	lock *sync.Mutex
}

// BuildLabelsValues - Designed to process Parameter Label Value
// pairs. The calling functions passes an array of Label Value
// string pairs which are used to produce a series of text lines.
// Each line of text consists of five text elements consisting of
// a left margin string, a parameter text label field, a parameter
// label right margin string, a parameter value label field, and
// a parameter value right margin string.
//
// These five text elements can be configured as a complete line of
// text depending on the value applied to input parameter
// 'lineTerminator'.
//
// Since the Label Value string pairs are passed by means of an
// array, this method is capable of producing a large number of
// text lines.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  paramLabelValues           []TextLabelValueStrings
//     - An array of Text Label Value string pairs. This array
//       contains the parameter label strings and the parameter
//       value strings which will be used to produce multiple lines
//       of text output.
//
//       The TextLabelValueStrings structure is listed as follows:
//
//       type TextLabelValueStrings struct {
//       	ParamLabel string
//       	ParamValue string
//        }
//
//       If either 'ParamLabel' or 'ParamValue' is submitted as an
//       empty or zero length string, it will be defaulted to a
//       single white space character " ".
//
//
//  leftMarginStr              string
//     - The contents of the string will be used as the left margin
//       for the 'paramLabelValues.ParamLabel' field.
//
//       If no left margin is required, set 'LeftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//       This Left Margin String will be applied to every text line
//       generated from the 'paramLabelValues' array.
//
//
//  paramLabelFieldLength      int
//     - Used to format the Text Label Field,
//       'paramLabelValues.ParamLabel'. This is the length of the
//       text field in which the formatted
//       'paramLabelValues.ParamLabel' string will be displayed. If
//       'paramLabelFieldLength' is less than the length of the
//       'paramLabelValues.ParamLabel' string, it will be
//       automatically set equal to the
//       'paramLabelValues.ParamLabel' string length.
//
//       This Parameter Label Field Length value will be applied to
//       every text line generated from the 'paramLabelValues' array
//
//       To automatically set the value of 'paramLabelFieldLength'
//       to the length of 'paramLabelValues.ParamLabel', set this
//       parameter to a value of  minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  paramLabelTextJustify      TextJustify
//      An enumeration value specifying the justification of the
//      'paramLabelValues.ParamLabel' string within the text field
//      specified by 'paramLabelFieldLength'.
//
//       This Parameter Label Text Justification value will be
//       applied to every text line generated from the
//       'paramLabelValues' array.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  paramLabelRightMarginStr   string
//     - The contents of the string will be used as the right
//       margin for the 'paramLabelValues.ParamLabel' field.
//
//       If no right margin is required, set
//       'paramLabelRightMarginStr' to a zero length or empty
//       string, and no right margin will be created.
//
//       This Parameter Label Right Margin String will be applied
//       to every text line generated from the 'paramLabelValues'
//       array.
//
//
//  paramValueFieldLength      int
//     - Used to format the Text Label Field,
//       'paramLabelValues.ParamValue'. This is the length of the
//       text field in which the formatted
//       'paramLabelValues.ParamValue' string will be displayed. If
//       'paramValueFieldLength' is less than the length of the
//       'paramLabelValues.ParamValue' string, it will be
//       automatically set equal to the
//       'paramLabelValues.ParamValue' string length.
//
//       This Parameter Value Field Length will be applied to every
//       text line generated from the 'paramLabelValues' array.
//
//       To automatically set the value of 'paramValueFieldLength'
//       to the length of 'paramLabelValues.ParamValue', set this
//       parameter to a value of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  paramValueTextJustify      TextJustify
//      An enumeration value specifying the justification of the
//      'paramLabelValues.ParamValue' string within the text field
//      specified by 'paramValueFieldLength'.
//
//       This Parameter Value Text Justification will be applied to
//       every text line generated from the 'paramLabelValues'
//       array.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  paramValueRightMarginStr   string
//     - The contents of the string will be used as the right
//       margin for the 'paramLabelValues.ParamValue' field.
//
//       This Parameter Value Right Margin String will be applied
//       to every text line generated from the 'paramLabelValues'
//       array.
//
//       If no right margin is required, set
//       'paramValueRightMarginStr' to a zero length or empty
//       string, and no right margin will be created.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       these five text element into a single line of text.
//
//       This Line Terminator String will be applied to every text
//       line generated from the 'paramLabelValues' array.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the five text
//       elements formatted by this method as single text field
//       will constitute a single line of text.
//
//       The most common usage sets this string to a new line
//       character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) BuildLabelsValues(
	paramLabelValues []TextLabelValueStrings,
	leftMarginStr string,
	paramLabelFieldLength int,
	paramLabelTextJustify TextJustify,
	paramLabelRightMarginStr string,
	paramValueFieldLength int,
	paramValueTextJustify TextJustify,
	paramValueRightMarginStr string,
	lineTerminator string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(1024)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"BuildLabelsValues()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(paramLabelValues) == 0 {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'paramLabelValues' is invalid!\n"+
			"The 'paramLabelValues' array has a length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	txtBuilderAtom := textStrBuilderAtom{}
	var strBuilder2 strings.Builder
	strBuilder2.Grow(256)

	for idx, item := range paramLabelValues {

		strBuilder2,
			err = txtBuilderAtom.fieldLabelWithMargins(
			leftMarginStr,
			item.ParamLabel,
			paramLabelFieldLength,
			paramLabelTextJustify,
			paramLabelRightMarginStr,
			"",
			ePrefix.XCpy(fmt.Sprintf(
				"strBuilder<-item[%v].paramLabel",
				idx)))

		if err != nil {
			return strBuilder, err
		}

		strBuilder.WriteString(strBuilder2.String())
		strBuilder2.Reset()

		strBuilder2,
			err = txtBuilderAtom.fieldLabelWithMargins(
			"",
			item.ParamValue,
			paramValueFieldLength,
			paramValueTextJustify,
			paramValueRightMarginStr,
			lineTerminator,
			ePrefix.XCpy(fmt.Sprintf(
				"strBuilder<-item[%v].paramValue",
				idx)))

		if err != nil {
			return strBuilder, err
		}

		strBuilder.WriteString(strBuilder2.String())
		strBuilder2.Reset()

	}

	return strBuilder, err
}

// BuildTextFormatters - Receives an array of TextFormatterDto
// objects and proceeds to generate multiple text fields and
// lines of text according to the specifications contained in each
// element of the TextFormatterDto array.
//
// Supported Text Formats include Text Label Fields, Text DateTime
// Fields, Text Filler Fields, Text Spacer Fields and Blank
// Lines.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  txtFormatters              []TextFormatterDto
//     - An array of TextFormatterDto objects containing
//       specifications required for creating Text Label Fields,
//       Text DateTime Fields, Text Filler Fields, Text Spacer
//       Fields and Blank Lines.
//
//       The TextFormatterDto contains a series of structures with
//       data specifications required for the generation of the
//       supported Text Fields and Text Lines.
//
//       type TextFormatterDto struct {
//       	FormatType TextFieldType
//       	// Required. This enumeration value specifies the type of Text
//       	// Format Operation to be performed. Depending on this value,
//       	// other member variables in the type will be accessed and used
//       	//
//       	// generated.
//       	//
//       	// Possible values are listed as follows:
//       	//   TxtFieldType.None()      - Invalid
//       	//   TxtFieldType.Label()     - Valid
//       	//   TxtFieldType.DateTime()  - Valid
//       	//   TxtFieldType.Filler()    - Valid
//       	//   TxtFieldType.Spacer()    - Valid
//       	//   TxtFieldType.BlankLine() - Valid
//
//       	DateTime TextFieldDateTimeDto
//       	// A structure containing data elements necessary for the
//       	// creation of Text Date/Time Fields.
//
//            type TextFieldDateTimeDto struct {
//            	LeftMarginStr string
//            	// The contents of the string will be used as the left margin
//            	// for the Text Field.
//            	//
//            	// If no left margin is required, set 'LeftMarginStr' to a zero
//            	// length or empty string, and no left margin will be created.
//
//            	FieldDateTime time.Time
//            	// If this Text Field is designated as a 'DateTime' Field, this
//            	// time value will be used to populate the Text Field.
//
//            	FieldDateTimeFormat string
//            	// If this Text Field is designated as a 'DateTime' Field, this
//            	// string will be used to format the Date/Time.
//            	//
//            	// If 'FieldDateTime' is set to a value greater than zero and
//            	// this 'ParamValueDateTimeFormat' string is empty (has a zero
//            	// length), a default Date/Time format string will be applied
//            	// as follows:
//            	//         "2006-01-02 15:04:05.000000000 -0700 MST"
//
//            	FieldLength int
//            	// Used to format Label Text Fields. This is the length of the
//            	// text field in which the 'FieldText' will be displayed. If
//            	// 'FieldLength' is less than the length of the 'FieldText'
//            	// string, it will be automatically set equal to the
//            	// 'FieldText' string length.
//            	//
//            	// To automatically set the value of 'FieldLength' to the
//            	// length of 'FieldText', set this parameter to a value of
//            	// minus one (-1).
//            	//
//            	// If this parameter is submitted with a value less than
//            	// minus one (-1) or greater than 1-million (1,000,000), an
//            	// error will be returned.
//            	//
//            	// If TextFieldType is set to 'Filler' or 'Spacer',
//            	// 'FieldLength' will be used to specify the number of Filler
//            	// or Spacer characters in the line.
//            	//
//            	// If TextFieldType is set to 'BlankLine', 'FieldLength' will
//            	// be used to specify the number of blank lines created.
//
//            	FieldJustify TextJustify
//            	// An enumeration which specifies the justification of the
//            	// 'FieldText' string within the text field specified by
//            	// 'FieldLength'.
//            	//
//            	// Text justification can only be evaluated in the context of
//            	// a text label, field length and a Text Justification object
//            	// of type TextJustify. This is because text labels with a
//            	// field length equal to or less than the length of the text
//            	// label never use text justification. In these cases, text
//            	// justification is completely ignored.
//            	//
//            	// If the field length is greater than the length of the text
//            	// label, text justification must be equal to one of these
//            	// three valid values:
//            	//     TextJustify(0).Left()
//            	//     TextJustify(0).Right()
//            	//     TextJustify(0).Center()
//            	//
//            	// You can also use the abbreviated text justification
//            	// enumeration syntax as follows:
//            	//
//            	//     TxtJustify.Left()
//            	//     TxtJustify.Right()
//            	//     TxtJustify.Center()
//
//            	RightMarginStr string
//            	// The contents of the string will be used as the right margin
//            	// for the Text Field.
//            	//
//            	// If no right margin is required, set 'RightMarginStr' to a
//            	// zero length or empty string, and no right margin will be
//            	// created.
//
//            	LineTerminator string
//            	// This string holds the character or characters which will be
//            	// used to terminate the formatted line of text output.
//            	//
//            	// The most common usage sets this string to a new line
//            	// character ("\n").
//            	//
//            	// If no Line Terminator is required, set 'lineTerminator' to
//            	// a zero length or empty string and no line termination
//            	// characters will be created.
//            }
//
//       	Filler TextFieldFillerDto
//       	// A structure containing data elements necessary for the
//       	// creation of Text Filler Fields.
//
//            type TextFieldFillerDto struct {
//            	LeftMarginStr string
//            	// The contents of the string will be used as the left margin
//            	// for the Text Field.
//            	//
//            	// If no left margin is required, set 'LeftMarginStr' to a zero
//            	// length or empty string, and no left margin will be created.
//
//            	FillerCharacters string
//            	// A string containing the text characters which will be
//            	// included in the Text Filler Field. The final Text Filler
//            	// Field will be constructed from the filler characters
//            	// repeated one or more times as specified by the
//            	// 'fillerCharsRepeatCount' parameter.
//            	//
//            	//  Text Field Filler Length =
//            	//    Length of fillerCharacters X fillerCharsRepeatCount
//            	//
//            	//    Example #1: fillerCharacters = "-*"
//            	//                fillerRepeatCount = 3
//            	//                Final Text Filler Field = "-*-*-*"
//            	//
//            	//    Example #2: fillerCharacters = "-"
//            	//                fillerRepeatCount = 3
//            	//                Final Text Filler Field = "---"
//            	//
//
//            	FillerCharsRepeatCount int
//            	// Controls the number of times 'fillerCharacters' is
//            	// repeated when constructing the final Text Filler Field
//            	// returned by this method. The actual length of the string
//            	// which will populated the completed Text Filler Field is
//            	// equal to the length of 'fillerCharacters' times the value
//            	// of 'fillerCharsRepeatCount'.
//            	//
//            	//  Text Field Filler Length =
//            	//    Length of fillerCharacters X fillerCharsRepeatCount
//            	//
//            	//    Example #1: fillerCharacters = "-*"
//            	//                fillerRepeatCount = 3
//            	//                Final Text Filler Field = "-*-*-*"
//            	//
//            	//    Example #2: fillerCharacters = "-"
//            	//                fillerRepeatCount = 3
//            	//                Final Text Filler Field = "---"
//            	//
//            	// If 'fillerCharsRepeatCount' has a value less than one (1) or
//            	// greater than one-million (1,000,000), an error will be
//            	// returned.
//
//            	RightMarginStr string
//            	// The contents of the string will be used as the right margin
//            	// for the Text Field.
//            	//
//            	// If no right margin is required, set 'RightMarginStr' to a
//            	// zero length or empty string, and no right margin will be
//            	// created.
//
//            	LineTerminator string
//            	// This string holds the character or characters which will be
//            	// used to terminate the formatted line of text output.
//            	//
//            	// The most common usage sets this string to a new line
//            	// character ("\n").
//            	//
//            	// If no Line Terminator is required, set 'lineTerminator' to
//            	// a zero length or empty string and no line termination
//            	// characters will be created.
//            }
//
//
//       	Label TextFieldLabelDto
//       	// A structure containing data elements necessary for the
//       	// creation of Text Label Fields.
//
//            type TextFieldLabelDto struct {
//            	LeftMarginStr string
//            	// The contents of the string will be used as the left margin
//            	// for the Text Field.
//            	//
//            	// If no left margin is required, set 'LeftMarginStr' to a zero
//            	// length or empty string, and no left margin will be created.
//
//            	FieldText string
//            	// The Text Field string or contents. If this string is empty
//            	// (has a zero (0) length) and is designated as a Label, Filler
//            	// or Spacer Text Field, an error will be generated.
//            	//
//            	// This string represents the contents of the Text Field.
//
//            	FieldLength int
//            	// Used to format Label Text Fields. This is the length of the
//            	// text field in which the 'FieldText' will be displayed. If
//            	// 'FieldLength' is less than the length of the 'FieldText'
//            	// string, it will be automatically set equal to the
//            	// 'FieldText' string length.
//            	//
//            	// To automatically set the value of 'FieldLength' to the
//            	// length of 'FieldText', set this parameter to a value of
//            	// minus one (-1).
//            	//
//            	// If this parameter is submitted with a value less than
//            	// minus one (-1) or greater than 1-million (1,000,000), an
//            	// error will be returned.
//            	//
//            	// If TextFieldType is set to 'Filler' or 'Spacer',
//            	// 'FieldLength' will be used to specify the number of Filler
//            	// or Spacer characters in the line.
//            	//
//            	// If TextFieldType is set to 'BlankLine', 'FieldLength' will
//            	// be used to specify the number of blank lines created.
//
//            	FieldJustify TextJustify
//            	// An enumeration which specifies the justification of the
//            	// 'FieldText' string within the text field specified by
//            	// 'FieldLength'.
//            	//
//            	// Text justification can only be evaluated in the context of
//            	// a text label, field length and a Text Justification object
//            	// of type TextJustify. This is because text labels with a
//            	// field length equal to or less than the length of the text
//            	// label never use text justification. In these cases, text
//            	// justification is completely ignored.
//            	//
//            	// If the field length is greater than the length of the text
//            	// label, text justification must be equal to one of these
//            	// three valid values:
//            	//     TextJustify(0).Left()
//            	//     TextJustify(0).Right()
//            	//     TextJustify(0).Center()
//            	//
//            	// You can also use the abbreviated text justification
//            	// enumeration syntax as follows:
//            	//
//            	//     TxtJustify.Left()
//            	//     TxtJustify.Right()
//            	//     TxtJustify.Center()
//
//            	RightMarginStr string
//            	// The contents of the string will be used as the right margin
//            	// for the Text Field.
//            	//
//            	// If no right margin is required, set 'RightMarginStr' to a
//            	// zero length or empty string, and no right margin will be
//            	// created.
//
//            	LineTerminator string
//            	// This string holds the character or characters which will be
//            	// used to terminate the formatted line of text output.
//            	//
//            	// The most common usage sets this string to a new line
//            	// character ("\n").
//            	//
//            	// If no Line Terminator is required, set 'lineTerminator' to
//            	// a zero length or empty string and no line termination
//            	// characters will be created.
//            }
//
//
//       	Spacer TextFieldSpacerDto
//       	// A structure containing data elements necessary for the
//       	// creation of Text Spacer Fields.
//
//            type TextFieldSpacerDto struct {
//            	LeftMarginStr string
//            	// The contents of the string will be used as the left margin
//            	// for the Text Field.
//            	//
//            	// If no left margin is required, set 'LeftMarginStr' to a zero
//            	// length or empty string, and no left margin will be created.
//
//            	FieldLength int
//            	//  An integer value greater than zero and less than 1,000,001
//            	//  which is used to specify the number of white space
//            	//  characters in the Text Spacer Field.
//            	//
//            	//  Examples:
//            	//     fieldLen = 1 produces text field " "
//            	//     fieldLen = 2 produces text field "  "
//            	//     fieldLen = 5 produces text field "     "
//
//            	RightMarginStr string
//            	// The contents of the string will be used as the right margin
//            	// for the Text Field.
//            	//
//            	// If no right margin is required, set 'RightMarginStr' to a
//            	// zero length or empty string, and no right margin will be
//            	// created.
//
//            	LineTerminator string
//            	// This string holds the character or characters which will be
//            	// used to terminate the formatted line of text output.
//            	//
//            	// The most common usage sets this string to a new line
//            	// character ("\n").
//            	//
//            	// If no Line Terminator is required, set 'lineTerminator' to
//            	// a zero length or empty string and no line termination
//            	// characters will be created.
//            }
//
//
//       	BlankLine TextLineBlankDto
//       	// A structure containing data elements necessary for the
//       	// creation of Blank Lines or New Lines.
//
//            type TextLineBlankDto struct {
//            	NumOfBlankLines int
//            	// The number of blank lines which will be generated by this
//            	// method.
//            	//
//            	// If this value is less than one (+1), an error will be
//            	// returned. Likewise, if this value is greater than
//            	// one-million (1,000,000), an error will be returned.
//            }
//
//       }
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing Formatted
//       Date/Time Text.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) BuildTextFormatters(
	txtFormatters []TextFormatterDto,
	errorPrefix interface{}) (
	strBuilder strings.Builder,
	err error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	strBuilder.Grow(2048)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"BuildTextFormatters()",
		"")

	if err != nil {
		return strBuilder, err
	}

	lenTxtFormatters := len(txtFormatters)

	if lenTxtFormatters == 0 {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtFormatters' is invalid!\n"+
			"The 'txtFormatters' array is empty and has a length of zero.\n",
			ePrefix.String())

		return strBuilder, err
	}

	txtBuilderAtom := textStrBuilderAtom{}

	txtBuilderElectron := textStrBuilderElectron{}

	var strBuilder2 strings.Builder

	for i := 0; i < lenTxtFormatters; i++ {

		if !txtFormatters[i].FormatType.XIsValid() {

			err = fmt.Errorf("%v\n"+
				"Error: txtFormatters[%v].FormatType is invalid!\n"+
				"FormatType String = '%v'\n"+
				"FormatType Int Value = '%v'\n",
				ePrefix.String(),
				i,
				txtFormatters[i].FormatType.String(),
				txtFormatters[i].FormatType.XValueInt())

			return strBuilder, err

		}

		if txtFormatters[i].FormatType == TxtFieldType.Label() {

			strBuilder2,
				err = txtBuilderAtom.fieldLabelWithMargins(
				txtFormatters[i].Label.LeftMarginStr,
				txtFormatters[i].Label.FieldText,
				txtFormatters[i].Label.FieldLength,
				txtFormatters[i].Label.FieldJustify,
				txtFormatters[i].Label.RightMarginStr,
				txtFormatters[i].Label.LineTerminator,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Label.FieldText",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFormatters[i].FormatType == TxtFieldType.DateTime() {

			strBuilder2,
				err = txtBuilderAtom.fieldDateTimeWithMargins(
				txtFormatters[i].DateTime.LeftMarginStr,
				txtFormatters[i].DateTime.FieldDateTime,
				txtFormatters[i].DateTime.FieldLength,
				txtFormatters[i].DateTime.FieldDateTimeFormat,
				txtFormatters[i].DateTime.FieldJustify,
				txtFormatters[i].DateTime.RightMarginStr,
				txtFormatters[i].DateTime.LineTerminator,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].DateTime.FieldDateTime",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFormatters[i].FormatType == TxtFieldType.Filler() {

			strBuilder2,
				err = txtBuilderAtom.fieldFillerWithMargins(
				txtFormatters[i].Filler.LeftMarginStr,
				txtFormatters[i].Filler.FillerCharacters,
				txtFormatters[i].Filler.FillerCharsRepeatCount,
				txtFormatters[i].Filler.RightMarginStr,
				txtFormatters[i].Filler.LineTerminator,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Filler.FillerCharacters",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFormatters[i].FormatType == TxtFieldType.BlankLine() {

			strBuilder2,
				err = txtBuilderElectron.lineBlank(
				txtFormatters[i].BlankLine.NumOfBlankLines,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].BlankLine.NumOfBlankLines",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else {
			// MUST BE TxtFieldType.Spacer()

			strBuilder2,
				err = txtBuilderElectron.fieldSpacerWithMargins(
				txtFormatters[i].Spacer.LeftMarginStr,
				txtFormatters[i].Spacer.FieldLength,
				txtFormatters[i].Spacer.RightMarginStr,
				txtFormatters[i].Spacer.LineTerminator,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Spacer.FieldLength",
						i)))

			if err != nil {
				return strBuilder, err
			}

		}

		strBuilder.WriteString(strBuilder2.String())
		strBuilder2.Reset()

	}

	return strBuilder, err
}

// BuildText - Generates formatted text from a Text Formatter
// Collection. This method is designed to produce formatted
// text from an array of TextFormatterDto objects contained
// in an instance of 'TextFormatterCollection'.
//
// The use case calls for the user to configure specifications
// and parameters for multiple lines of text in a single Text
// Formatter Collection. This method will then receive those
// parameters and proceed to generate multiple lines of text
// for screen displays, file output or printing.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  txtFmtSpecs                TextFormatterCollection
//     - An instance of TextFormatterCollection. This type contains
//       an array of TextFormatterDto objects used in generating
//       one or more text fields or entire lines of text.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If the method completes successfully, it will return an
//       instance of strings.Builder containing all the formatted
//       text generated from input parameter 'txtFmtSpecs'.
//
//
//  error
//     - If the method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) BuildText(
	txtFmtSpecs *TextFormatterCollection,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	strBuilder := strings.Builder{}

	strBuilder.Grow(512)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"BuildText()",
		"")

	if err != nil {
		return strBuilder, err
	}

	lenTextFormatterCol :=
		txtFmtSpecs.GetLengthFormatterCollection()

	if lenTextFormatterCol == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtFmtSpecs' is invalid!\n"+
			"The Text Formatter Collection is empty.\n",
			ePrefix.String())

		return strBuilder, err

	}

	txtBuilderAtom := textStrBuilderAtom{}

	for i := 0; i < lenTextFormatterCol; i++ {

		strBuilder2 := strings.Builder{}

		if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.Label() {

			strBuilder2,
				err = txtBuilderAtom.buildLabelFieldWithDto(
				txtFmtSpecs.fmtCollection[i].Label,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Label.FieldText",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.DateTime() {

			strBuilder2,
				err = txtBuilderAtom.buildDateTimeFieldWithDto(
				txtFmtSpecs.fmtCollection[i].DateTime,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].DateTime.FieldText",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.Filler() {

			strBuilder2,
				err = txtBuilderAtom.buildFillerFieldWithDto(
				txtFmtSpecs.fmtCollection[i].Filler,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Filler.FieldText",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.Spacer() {

			strBuilder2,
				err = txtBuilderAtom.buildSpacerFieldWithDto(
				txtFmtSpecs.fmtCollection[i].Spacer,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].Spacer.FieldText",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.BlankLine() {

			strBuilder2,
				err = txtBuilderAtom.buildTextLineBlankWithDto(
				txtFmtSpecs.fmtCollection[i].BlankLine,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].BlankLine",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.SolidLine() {

			strBuilder2,
				err = txtBuilderAtom.buildTextLineSolidWithDto(
				txtFmtSpecs.fmtCollection[i].SolidLine,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].SolidLine",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else if txtFmtSpecs.fmtCollection[i].FormatType ==
			TxtFieldType.LineColumns() {

			strBuilder2,
				err = txtBuilderAtom.buildTextLineColumns(
				txtFmtSpecs.fmtCollection[i].LineColumns,
				ePrefix.XCpy(
					fmt.Sprintf(
						"strBuilder<-txtFormatters[%v].LineColumns",
						i)))

			if err != nil {
				return strBuilder, err
			}

		} else {

			continue
		}

		strBuilder.WriteString(strBuilder2.String())

		strBuilder2.Reset()

	}

	return strBuilder, err
}

// FieldDateTime - Creates a date time value formatted as a text
// field. Users have the option to format this date time text
// field with a line terminator (a.k.a. new line character '\n')
// thereby converting this text field to a separate stand-alone
// line of text.
//
// The resulting formatted text is returned as an instance of
// strings.Builder.
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of this string will be used as the left
//       margin for the date time text field.
//
//       If no left margin is required, set 'leftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  fieldDateTime              time.Time
//     - The date/time value which will be formatted as a text
//       string.
//
//       If this parameter is set equal to zero, an error will be
//       generated when attempting to create a text field with a
//       Text Builder method.
//
//
//  fieldDateTimeFormat        string
//    - This string will be used to format the date/time value
//      'fieldDateTime' as a text string.
//
//       If this 'fieldDateTimeFormat' string is empty (has a zero
//       length), a default Date/Time format string will be applied
//       as follows:
//         "2006-01-02 15:04:05.000000000 -0700 MST"
//
//
//  fieldLength                int
//     - Used to format date time text field. This is the length of
//       the text field in which the formatted date time text
//       string will be displayed. If 'fieldLength' is less than the
//       length of the date time string, it will be automatically
//       set equal to the date time string length.
//
//       If 'fieldLength' is greater than the length of the date
//       time text string, the 'fieldJustify' parameter will be
//       used to configure or justify the text within the
//       boundaries the text field defined by 'fieldLength'.
//
//       To automatically set the value of 'fieldLength' to the
//       length of the date time text field, set this parameter to
//       a value of  minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000),
//       an error will be returned.
//
//
//  fieldJustify               TextJustify
//      An enumeration value specifying the justification of the
//      date time text string within the text field specified by
//      'fieldLength'.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the date
//      time text string, text justification must be equal to one
//      of these three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted date time text thereby
//       converting this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the text line
//       consists of the text label field and no other text
//       elements. Any string of text characters will be accepted
//       for this parameter.
//
//       Again, the most common usage sets this string to a new
//       line character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  maxLineLength              int
//     - The maximum length of the line on which this date time
//       text field will be presented.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       'maxLineLength' is used in conjunction with parameter
//       'turnAutoLineLengthBreaksOn' to automatically place text
//       fields on separate text lines when that text exceeds the
//       maximum text line length ('maxLineLength'). Therefore,
//       paramter 'turnAutoLineLengthBreaksOn' controls whether
//       automatic line breaks using 'maxLineLength' will be
//       applied.
//
//       If the value of 'maxLineLength' is less than one (1), it
//       will be automatically converted to minus one (-1).
//
//
//  turnAutoLineLengthBreaksOn bool
//     - This parameter controls whether text lines which exceed
//       the maximum line length ('maxLineLength') are broken up
//       and presented on the following line.
//
//       To apply automatic line breaking at the maximum line
//       length, set the value of this parameter to 'true'.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing Formatted
//       Date/Time Text.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldDateTime(
	leftMarginStr string,
	fieldDateTime time.Time,
	fieldDateTimeFormat string,
	fieldLength int,
	fieldJustify TextJustify,
	rightMarginStr string,
	lineTerminator string,
	maxLineLength int,
	turnAutoLineLengthBreaksOn bool,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	strBuilder := strings.Builder{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldDateTime()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if fieldDateTime.IsZero() {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldDateTime' is invalid!\n"+
			"'fieldDateTime' has a zero Date/Time value.\n",
			ePrefix.String())

		return strBuilder, err

	}

	if fieldLength < -1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value less than minus one (-1).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if fieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value greater than one-million (1,000,000).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if maxLineLength < 1 {
		maxLineLength = -1
	}

	dateTimeDto := TextFieldDateTimeDto{
		FormatType:                 TxtFieldType.DateTime(),
		LeftMarginStr:              leftMarginStr,
		FieldDateTime:              fieldDateTime,
		FieldDateTimeFormat:        fieldDateTimeFormat,
		FieldLength:                fieldLength,
		FieldJustify:               fieldJustify,
		RightMarginStr:             rightMarginStr,
		LineTerminator:             lineTerminator,
		MaxLineLength:              maxLineLength,
		TurnAutoLineLengthBreaksOn: turnAutoLineLengthBreaksOn,
		lock:                       nil,
	}

	return textStrBuilderAtom{}.ptr().buildDateTimeFieldWithDto(
		dateTimeDto,
		ePrefix.XCpy(
			"strBuilder<-dateTime"))
}

// FieldDateTimeDto - Creates a date time value formatted as a text
// field using parameters supplied by a Text Field Date Time Data
// Transfer Object, TextFieldDateTimeDto.
//
// Users have the option to format this date time text
// field with a line terminator (a.k.a. new line character '\n')
// thereby converting this field to a separate stand-alone line of
// text.
//
// The resulting formatted text is returned as an instance of
// strings.Builder.
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  textDateTimeDto            TextFieldDateTimeDto
//     - An instance of TextFieldDateTimeDto which contains all the
//       necessary data parameters to produce a date time text
//       field.
//
//       The Text Field Date Time Data Transfer Object is defined
//       as follows:
//
//
//       type TextFieldDateTimeDto struct {
//
//         FormatType                  TextFieldType
//          Required. This enumeration value specifies the type of
//          Text Format Operation to be performed.
//
//          For the TextFieldDateTimeDto Format Type, this value
//          should always be set to:
//            TxtFieldType.DateTime()
//
//         LeftMarginStr               string
//          The contents of the string will be used as the left
//          margin for the Text Field.
//
//          If no left margin is required, set 'LeftMarginStr' to a
//          zero length or empty string, and no left margin will be
//          created.
//
//         FieldDateTime               time.Time
//          This time value will be converted to a string and used
//          to populate the Date Time Text Field.
//
//         FieldDateTimeFormat         string
//          This string will be used to format the Date/Time value
//          contained in parameter 'FieldDateTime' as text.
//
//          If 'FieldDateTime' is set to a value greater than zero
//          and this 'FieldDateTimeFormat' string is empty (has a
//          zero length), a default Date/Time format string will be
//          applied as follows:
//                  "2006-01-02 15:04:05.000000000 -0700 MST"
//
//         FieldLength                 int
//          Used to format Text Fields. This is the length of the
//          text field in which the date time text field will be
//          displayed. If 'FieldLength' is less than the length of
//          the date time text string, it will be automatically set
//          equal to the date time text string length.
//
//          If 'FieldLength' is greater than the length of the date
//          time text string, the 'FieldJustify' parameter will be
//          used to configure or justify the text with the
//          boundaries of the text field defined by 'FieldLength'.
//
//          To automatically set the value of 'FieldLength' to the
//          length of the date time text string, set this parameter
//          to a value of minus one (-1).
//
//          If this parameter is submitted with a value less than
//          minus one (-1) or greater than 1-million (1,000,000),
//          an error will be returned when attempting to build the
//          final text output.
//
//
//         FieldJustify                TextJustify
//          An enumeration which specifies the justification of the
//          date time text string within the text field specified
//          by 'FieldLength'.
//
//          Text justification can only be evaluated in the context
//          of a text label, field length and a Text Justification
//          object of type TextJustify. This is because text labels
//          with a field length equal to or less than the length of
//          the text label never use text justification. In these
//          cases, text justification is completely ignored.
//
//          If the field length is greater than the length of the
//          date time text string, text justification must be equal
//          to one of these three valid values:
//              TextJustify(0).Left()
//              TextJustify(0).Right()
//              TextJustify(0).Center()
//
//          You can also use the abbreviated text justification
//          enumeration syntax as follows:
//
//              TxtJustify.Left()
//              TxtJustify.Right()
//              TxtJustify.Center()
//
//         RightMarginStr string
//          The contents of the string will be used as the right margin
//          for the Text Field.
//
//          If no right margin is required, set 'RightMarginStr' to a
//          zero length or empty string, and no right margin will be
//          created.
//
//         LineTerminator              string
//          This string holds the character or characters which will be
//          used to terminate the formatted line of text output.
//
//          The most common usage sets this string to a new line
//          character ("\n").
//
//          If no Line Terminator is required, set 'lineTerminator' to
//          a zero length or empty string and no line termination
//          characters will be created.
//
//         MaxLineLength               int
//          Set this parameter to minus one -1 to specify an
//          unlimited line length for this text line.
//
//         TurnAutoLineLengthBreaksOn  bool
//          When this parameter is set to 'true', text fields which
//          extend beyond the maximum line length ('MaxLineLength')
//          will be terminated with a new line character ('\n') and
//          placed on the following line of text.
//
//       }
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing Formatted
//       Date/Time Text.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldDateTimeDto(
	textDateTimeDto TextFieldDateTimeDto,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	strBuilder := strings.Builder{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldDateTimeDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if textDateTimeDto.FieldDateTime.IsZero() {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textDateTimeDto.FieldDateTime' is invalid!\n"+
			"'textDateTimeDto.FieldDateTime' has a zero Date/Time value.\n",
			ePrefix.String())

		return strBuilder, err

	}

	if textDateTimeDto.FieldLength < -1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textDateTimeDto.FieldLength' is invalid!\n"+
			"'textDateTimeDto.FieldLength' has a value less than minus one (-1).\n"+
			"textDateTimeDto.FieldLength = '%v'\n",
			ePrefix.String(),
			textDateTimeDto.FieldLength)

		return strBuilder, err

	}

	if textDateTimeDto.FieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textDateTimeDto.FieldLength' is invalid!\n"+
			"'textDateTimeDto.FieldLength' has a value greater than one-million (1,000,000).\n"+
			"textDateTimeDto.FieldLength = '%v'\n",
			ePrefix.String(),
			textDateTimeDto.FieldLength)

		return strBuilder, err

	}

	if textDateTimeDto.MaxLineLength < 1 {
		textDateTimeDto.MaxLineLength = -1
	}

	return textStrBuilderAtom{}.ptr().buildDateTimeFieldWithDto(
		textDateTimeDto,
		ePrefix.XCpy(
			"strBuilder<-textDateTimeDto"))
}

// FieldFiller - The Filler Text Field consists of a single
// character or multiple character sequence which is replicated
// some number of times to create the entire length of the Filler
// Text Field.
//
// Text Filler Fields are commonly used as margins containing
// multiple white space characters, or line separators containing
// multiple dashes, equal signs or underscore characters. Text
// Filler Fields consist of filler characters ('fillerCharacters')
// and the filler characters repeat count
// ('fillerCharsRepeatCount'). A filler field is made up of one or
// more filler characters. These filler characters are repeated one
// or more times in order to construct the complete filler field as
// shown in the following examples:
//
//  Example 1:
//   Filler Characters = "-"
//   Filler Characters Repeat Count = 3
//   Formatted Text = "---"
//
//  Example 2:
//   Filler Characters = "-*"
//   Filler Characters Repeat Count = 3
//   Formatted Text = "-*-*-*"
//
// This single Filler Text Field can be configured as a separate
// stand-alone line of text depending on the value applied to input
// parameter 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of this string will be used as the left
//       margin for the Text Filler Field.
//
//       If no left margin is required, set 'leftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  fillerCharacters           string
//     - A string containing the text characters which will be
//       included in the Text Filler Field. The final Text Filler
//       Field will be constructed from the filler characters
//       repeated one or more times as specified by the
//       'fillerCharsRepeatCount' parameter.
//
//        Text Field Filler Length =
//          Length of fillerCharacters X fillerCharsRepeatCount
//
//          Example #1: fillerCharacters = "-*"
//                      fillerRepeatCount = 3
//                      Final Text Filler Field = "-*-*-*"
//
//          Example #2: fillerCharacters = "-"
//                      fillerRepeatCount = 3
//                      Final Text Filler Field = "---"
//
//       If 'fillerCharacters' is submitted as an empty or zero
//       length string, this method will return an error.
//
//
//  fillerCharsRepeatCount     int
//     - Controls the number of times 'fillerCharacters' is
//       repeated when constructing the final Text Filler Field
//       returned by this method. The actual length of the string
//       which will populated the completed Text Filler Field is
//       equal to the length of 'fillerCharacters' times the value
//       of 'fillerCharsRepeatCount'.
//
//        Text Field Filler Length =
//          Length of fillerCharacters X fillerCharsRepeatCount
//
//          Example #1: fillerCharacters = "-*"
//                      fillerRepeatCount = 3
//                      Final Text Filler Field = "-*-*-*"
//
//          Example #2: fillerCharacters = "-"
//                      fillerRepeatCount = 3
//                      Final Text Filler Field = "---"
//
//       If 'fillerCharsRepeatCount' has a value less than one (1) or
//       greater than one-million (1,000,000), an error will be
//       returned.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the text line
//       consists of the text label field and no other text
//       elements. Any string of text characters will be accepted
//       for this parameter.
//
//       Again, the most common usage sets this string to a new
//       line character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  maxLineLength              int
//     - The maximum length of the line on which this label text
//       will be presented.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       'maxLineLength' is used in conjunction with parameter
//       'turnAutoLineLengthBreaksOn' to automatically place text
//       fields on separate text lines when that text exceeds the
//       maximum text line length ('maxLineLength'). Therefore,
//       paramter 'turnAutoLineLengthBreaksOn' controls whether
//       automatic line breaks using 'maxLineLength' will be
//       applied.
//
//       If the value of 'maxLineLength' is less than zero (0), it
//       will be automatically converted to minus one (-1).
//
//
//  turnAutoLineLengthBreaksOn bool
//     - This parameter controls whether text lines which exceed
//       the maximum line length ('maxLineLength') are broken up
//       and presented on the following line.
//
//       To apply automatic line breaking at the maximum line
//       length, set the value of this parameter to 'true'.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strBuilder                 strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldFiller(
	leftMarginStr string,
	fillerCharacters string,
	fillerCharsRepeatCount int,
	rightMarginStr string,
	lineTerminator string,
	maxLineLength int,
	turnAutoLineLengthBreaksOn bool,
	errorPrefix interface{}) (
	strBuilder strings.Builder,
	err error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	strBuilder.Grow(256)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldFiller()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(fillerCharacters) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fillerCharacters' is invalid!\n"+
			"'fillerCharacters' is an empty string with a string\n"+
			"length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err

	}

	if fillerCharsRepeatCount < 1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fillerCharsRepeatCount' is invalid!\n"+
			"'fillerCharsRepeatCount' has a value less than one (1).\n"+
			"fillerCharsRepeatCount = '%v'\n",
			ePrefix.String(),
			fillerCharsRepeatCount)

		return strBuilder, err
	}

	if fillerCharsRepeatCount > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fillerCharsRepeatCount' is invalid!\n"+
			"'fillerCharsRepeatCount' has a value greater than one-million (1,000,000).\n"+
			"fillerCharsRepeatCount = '%v'\n",
			ePrefix.String(),
			fillerCharsRepeatCount)

		return strBuilder, err
	}

	if maxLineLength < 1 {
		maxLineLength = -1
	}

	fillerFieldDto := TextFieldFillerDto{
		FormatType:                 TxtFieldType.Filler(),
		LeftMarginStr:              leftMarginStr,
		FillerCharacters:           fillerCharacters,
		FillerCharsRepeatCount:     fillerCharsRepeatCount,
		RightMarginStr:             rightMarginStr,
		LineTerminator:             lineTerminator,
		MaxLineLength:              maxLineLength,
		TurnAutoLineLengthBreaksOn: turnAutoLineLengthBreaksOn,
		lock:                       nil,
	}

	return textStrBuilderAtom{}.ptr().buildFillerFieldWithDto(
		fillerFieldDto,
		ePrefix.XCpy(
			"strBuilder<-fillerFieldDto"))
}

// FieldFillerDto - Creates a Filler Text Field string using
// parameters supplied by a Text Field Filler Data Transfer Object,
// TextFieldFillerDto.
//
// The Text Filler Field consists of a single character or multiple
// character sequence which is replicated some number of times to
// create the entire length of the Filler Text Field.
//
// Text Filler Fields are commonly used as margins containing
// multiple white space characters, or line separators containing
// multiple dashes, equal signs or underscore characters. Text
// Filler Fields consist of filler characters ('fillerCharacters')
// and the filler characters repeat count
// ('fillerCharsRepeatCount'). A filler field is made up of one or
// more filler characters. These filler characters are repeated one
// or more times in order to construct the complete filler field as
// shown in the following examples:
//
//  Example 1:
//   Filler Characters = "-"
//   Filler Characters Repeat Count = 3
//   Formatted Text = "---"
//
//  Example 2:
//   Filler Characters = "-*"
//   Filler Characters Repeat Count = 3
//   Formatted Text = "-*-*-*"
//
// This single Filler Text Field can be configured as a separate
// stand-alone line of text depending on the value applied to input
// parameter 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  textFillerDto              TextFieldFillerDto
//     - An instance of TextFieldFillerDto which contains all the
//       necessary data parameters to produce a Text Filler Field.
//
//       The Text Field Filler Data Transfer Object is defined as
//       follows:
//
//       type TextFieldFillerDto struct {
//
//        FormatType                   TextFieldType
//         Required. This enumeration value specifies the type of
//         Text Format Operation to be performed.
//
//         For the TextFieldFillerDto Format Type, this value
//         should always be set to:
//           TxtFieldType.Filler()
//
//        LeftMarginStr                string
//         The contents of the string will be used as the left
//         margin for the Text Field.
//
//         If no left margin is required, set 'LeftMarginStr' to a
//         zero length or empty string, and no left margin will be
//         created.
//
//        FillerCharacters             string
//         A string containing the text characters which will be
//         included in the Text Filler Field. The final Text Filler
//         Field will be constructed from the filler characters
//         repeated one or more times as specified by the
//         'FillerCharsRepeatCount' parameter.
//
//          Text Field Filler Length =
//            Length of fillerCharacters X fillerCharsRepeatCount
//
//            Example #1: FillerCharacters = "-*"
//                        FillerCharsRepeatCount = 3
//                        Final Text Filler Field = "-*-*-*"
//
//            Example #2: FillerCharacters = "-"
//                        FillerCharsRepeatCount = 3
//                        Final Text Filler Field = "---"
//
//
//        FillerCharsRepeatCount       int
//         Controls the number of times 'FillerCharacters' is
//         repeated when constructing the final Text Filler Field.
//         The actual length of the string which will populate the
//         completed Text Filler Field is equal to the length of
//         'FillerCharacters' times the value of
//         'FillerCharsRepeatCount'.
//
//          Text Field Filler Length =
//            Length of FillerCharacters X FillerCharsRepeatCount
//
//            Example #1: FillerCharacters = "-*"
//                        FillerRepeatCount = 3
//                        Final Text Filler Field = "-*-*-*"
//
//            Example #2: FillerCharacters = "-"
//                        FillerRepeatCount = 3
//                        Final Text Filler Field = "---"
//
//         If 'FillerCharsRepeatCount' has a value less than one
//         (1) or greater than one-million (1,000,000), an error
//         will be returned when attempting to format text.
//
//        RightMarginStr               string
//         The contents of the string will be used as the right
//         margin for the Text Filler Field.
//
//         If no right margin is required, set 'RightMarginStr' to
//         a zero length or empty string, and no right margin will
//         be created.
//
//        LineTerminator               string
//         This string holds the character or characters which will
//         be used to terminate the formatted line of text output
//         thereby converting this text element into a valid
//         stand-alone line of text. Line Termination is optional.
//         Populate this string only if this text output should be
//         formatted as a separate line of text.
//
//         The most common usage sets this string to a new line
//         character ("\n").
//
//         If no Line Terminator is required, set 'lineTerminator'
//         to a zero length or empty string and no line termination
//         characters will be created.
//
//        MaxLineLength                int
//         The maximum length of the line on which this label text
//         will be presented.
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//         'MaxLineLength' is used in conjunction with parameter
//         'TurnAutoLineLengthBreaksOn' to automatically place text
//         fields on separate text lines when that text exceeds the
//         maximum text line length ('MaxLineLength'). Therefore,
//         paramter 'turnAutoLineLengthBreaksOn' controls whether
//         automatic line breaks using 'MaxLineLength' will be
//         applied.
//
//         If the value of 'maxLineLength' is less than one (1), it
//         will be automatically converted to minus one (-1).
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//        TurnAutoLineLengthBreaksOn   bool
//         This parameter controls whether text lines which exceed
//         the maximum line length ('MaxLineLength') are broken up
//         and presented on the following line.
//
//         To apply automatic line breaking at the maximum line
//         length, set the value of this parameter to 'true'.
//       }
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strBuilder                 strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldFillerDto(
	textFillerDto TextFieldFillerDto,
	errorPrefix interface{}) (
	strBuilder strings.Builder,
	err error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	strBuilder.Grow(256)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldFillerDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(textFillerDto.FillerCharacters) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textFillerDto.FillerCharacters' is invalid!\n"+
			"'textFillerDto.FillerCharacters' is an empty string with a string\n"+
			"length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err

	}

	if textFillerDto.FillerCharsRepeatCount < 1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textFillerDto.FillerCharsRepeatCount' is invalid!\n"+
			"'textFillerDto.FillerCharsRepeatCount' has a value less than one (1).\n"+
			"textFillerDto.FillerCharsRepeatCount = '%v'\n",
			ePrefix.String(),
			textFillerDto.FillerCharsRepeatCount)

		return strBuilder, err
	}

	if textFillerDto.FillerCharsRepeatCount > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textFillerDto.FillerCharsRepeatCount' is invalid!\n"+
			"'textFillerDto.FillerCharsRepeatCount' has a value greater than one-million (1,000,000).\n"+
			"textFillerDto.FillerCharsRepeatCount = '%v'\n",
			ePrefix.String(),
			textFillerDto.FillerCharsRepeatCount)

		return strBuilder, err
	}

	if textFillerDto.MaxLineLength < 1 {
		textFillerDto.MaxLineLength = -1
	}

	return textStrBuilderAtom{}.ptr().buildFillerFieldWithDto(
		textFillerDto.CopyOut(),
		ePrefix.XCpy(
			"strBuilder<-textFillerDto"))
}

// FieldLabel - Formats a single text label field and writes the
// output string to an instance of strings.Builder which is
// returned to the calling function.
//
// Users have the option to format this text label with a line
// terminator (a.k.a. new line character '\n') thereby creating
// a separate stand-alone line of text.
//
// Text Label Example 1:
//   leftMarginStr = "" // Empty String
//   fieldText = "Hello"  // Length = 5 characters
//   fieldLength = 7
//   fieldJustify = TxtJustify.Center()
//   rightMarginStr = "" // Empty String
//   lineTerminator = "" // Empty String
//   maxLineLength = -1
//   turnAutoLineLengthBreaksOn = false
//   Final Text Label string = " Hello "
//
// Text Label Example 2:
//   leftMarginStr = "" // Empty String
//   fieldText = "Hello"  // Length = 5 characters
//   fieldLength = 7
//   fieldJustify = TxtJustify.Center()
//   rightMarginStr = "" // Empty String
//   lineTerminator = "\n" // Empty String
//   maxLineLength = -1
//   turnAutoLineLengthBreaksOn = false
//   Final Text Label string = " Hello \n"
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of this string will be used as the left
//       margin for the text label field.
//
//       If no left margin is required, set 'leftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  fieldText                  interface{}
//     - This parameter is an empty interface which must contain
//       one of several specific types. This empty interface type
//       will be converted to a string and configured as the text
//       field for this label.
//
//       Supported types which may be submitted through this empty
//       interface parameter are listed as follows:
//          time.Time (Converted using default format)
//          string
//          bool
//          uint, uint8, uint16, uint32, uint64,
//          int, int8, int16, int32, int64
//          float32, float64
//          *big.Int *big.Float
//          fmt.Stringer (types that support this interface)
//          TextInputParamFieldDateTimeDto
//                (Converts date time to string)
//
//       If the 'fieldText' is not convertible to one of the
//       supported types, the 'column1Field' string will be
//       populated with an error message.
//
//       If the converted string value for 'column1Field' is empty,
//       it will be defaulted to a single white space character
//       (" ").
//
//
//  fieldLength                int
//     - Used to format Text Label Fields. This is the length of
//       the text field in which the formatted 'fieldText' string
//       will be displayed. If 'fieldLength' is less than the
//       length of the 'fieldText' string, it will be automatically
//       set equal to the 'labelText' string length.
//
//       If 'fieldLength' is greater than the length of the
//       'fieldText' text string, the 'fieldJustify' parameter will
//       be used to configure or justify the text within the
//       boundaries of the text field defined by 'fieldLength'.
//
//       To automatically set the value of 'fieldLength' to the
//       length of 'fieldText', set this parameter to a value
//       of  minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000),
//       an error will be returned.
//
//
//  fieldJustify               TextJustify
//      An enumeration value specifying the justification of the
//      'fieldText' string within the text field specified by
//      'fieldLength'.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  rightMarginStr             string
//     - The contents of this string will be used as the right
//       margin for the text label field.
//
//       If no right margin is required, set 'rightMarginStr' to a
//       zero length or empty string, and no right margin will be
//       created.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the text line
//       consists of the text label field and no other text
//       elements. Any string of text characters will be accepted
//       for this parameter.
//
//       Again, the most common usage sets this string to a new
//       line character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  maxLineLength              int
//     - The maximum length of the line on which this label text
//       will be presented.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       If the value of 'maxLineLength' is less than one (1), it
//       will be automatically converted to minus one (-1).
//
//       'maxLineLength' is used in conjunction with parameter
//       'turnAutoLineLengthBreaksOn' to automatically place text
//       fields on separate text lines when that text exceeds the
//       maximum text line length ('maxLineLength'). Therefore,
//       paramter 'turnAutoLineLengthBreaksOn' controls whether
//       automatic line breaks using 'maxLineLength' will be
//       applied.
//
//
//  turnAutoLineLengthBreaksOn bool
//     - This parameter controls whether text lines which exceed
//       the maximum line length ('maxLineLength') are broken up
//       and presented on the following line.
//
//       To apply automatic line breaking at the maximum line
//       length, set the value of this parameter to 'true'.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted text
//       characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldLabel(
	leftMarginStr string,
	fieldText interface{},
	fieldLength int,
	fieldJustify TextJustify,
	rightMarginStr string,
	lineTerminator string,
	maxLineLength int,
	turnAutoLineLengthBreaksOn bool,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldLabel()",
		"")

	if err != nil {
		return strBuilder, err
	}

	var fieldTextStr string

	fieldTextStr,
		err = textSpecificationAtom{}.ptr().
		convertParamEmptyInterfaceToString(
			fieldText,
			"fieldText",
			ePrefix.XCpy(
				"fieldTextStr<-fieldText"))

	if err != nil {
		return strBuilder, err
	}

	if len(fieldTextStr) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldText' is invalid!\n"+
			"'fieldText' converted as an empty string with a\n"+
			"string length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	if fieldLength < -1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value less than minus one (-1).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if fieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value greater than one-million (1000000).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if maxLineLength < 1 {
		maxLineLength = -1
	}

	labelFieldDto := TextFieldLabelDto{
		FormatType:                 TxtFieldType.Label(),
		LeftMarginStr:              leftMarginStr,
		FieldText:                  fieldTextStr,
		FieldLength:                fieldLength,
		FieldJustify:               fieldJustify,
		RightMarginStr:             rightMarginStr,
		LineTerminator:             lineTerminator,
		MaxLineLength:              maxLineLength,
		TurnAutoLineLengthBreaksOn: turnAutoLineLengthBreaksOn,
		lock:                       nil,
	}

	return textStrBuilderAtom{}.ptr().buildLabelFieldWithDto(
		labelFieldDto,
		ePrefix.XCpy(
			"strBuilder<-labelFieldDto"))
}

// FieldLabelDto - Formats a single text label field and writes the
// output string to an instance of strings.Builder which is
// returned to the calling function. This text label string is
// created from a Text Field Label Data Transfer Object
// (TextFieldLabelDto) passed as an input parameter.
//
// Users have the option to format this text label with a line
// terminator (a.k.a. new line character '\n') thereby creating
// a separate stand-alone line of text.
//
// Text Label Example 1:
//   leftMarginStr = "" // Empty String
//   fieldText = "Hello"  // Length = 5 characters
//   fieldLength = 7
//   fieldJustify = TxtJustify.Center()
//   rightMarginStr = "" // Empty String
//   lineTerminator = "" // Empty String
//   maxLineLength = -1
//   turnAutoLineLengthBreaksOn = false
//   Final Text Label string = " Hello "
//
// Text Label Example 2:
//   leftMarginStr = "" // Empty String
//   fieldText = "Hello"  // Length = 5 characters
//   fieldLength = 7
//   fieldJustify = TxtJustify.Center()
//   rightMarginStr = "" // Empty String
//   lineTerminator = "\n" // Empty String
//   maxLineLength = -1
//   turnAutoLineLengthBreaksOn = false
//   Final Text Label string = " Hello \n"
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  textLabelDto                       TextFieldLabelDto
//     - An instance of TextFieldLabelDto which contains all the
//       necessary data parameters to produce a text label.
//
//       The Text Field Label Data Transfer Object is defined as
//       follows:
//
//       type TextFieldLabelDto struct {
//
//         FormatType                  TextFieldType
//           Required. This enumeration value specifies the type of
//           Text Format Operation to be performed.
//
//           For TextFieldLabelDto Format Type, this value should
//           always be set to:
//             TxtFieldType.Label()
//
//         LeftMarginStr               string
//           The contents of the string will be used as the left
//           margin for the Text Field.
//
//           If no left margin is required, set 'LeftMarginStr' to
//           a zero length or empty string, and no left margin will
//           be created.
//
//         FieldText                   string
//           The Text Field string or contents. If this string is
//           empty (has a zero (0) length) it will be automatically
//           converted to a single white space character (" ").
//
//           This string represents the contents of the Text Field.
//
//         FieldLength                 int
//           Used to format FieldText string. This is the length of
//           the text field in which the 'FieldText' will be
//           displayed. If 'FieldLength' is less than the length of
//           the 'FieldText' string, it will be automatically set
//           equal to the 'FieldText' string length.
//
//           If 'FieldLength' is greater than the length of the
//           'FieldText' text string, the 'FieldJustify' parameter
//           will be used to configure or justify the text within
//           the boundaries of the text field defined by
//           'FieldLength'.
//
//           To automatically set the value of 'FieldLength' to the
//           length of 'FieldText', set this parameter to a value
//           of minus one (-1).
//
//           If this parameter is submitted with a value less than
//           minus one (-1) or greater than 1-million (1,000,000),
//           an error will be returned.
//
//         FieldJustify                TextJustify
//           An enumeration which specifies the justification of
//           the 'FieldText' string within the text field specified
//           by 'FieldLength'.
//
//           Text justification can only be evaluated in the
//           context of a text label, field length and a Text
//           Justification object of type TextJustify. This is
//           because text labels with a field length equal to or
//           less than the length of the text label never use text
//           justification. In these cases, text justification is
//           completely ignored.
//
//           If the field length is greater than the length of the
//           text label, text justification must be equal to one of
//           these three valid values:
//               TextJustify(0).Left()
//               TextJustify(0).Right()
//               TextJustify(0).Center()
//
//           You can also use the abbreviated text justification
//           enumeration syntax as follows:
//
//               TxtJustify.Left()
//               TxtJustify.Right()
//               TxtJustify.Center()
//
//         RightMarginStr              string
//           The contents of the string will be used as the right
//           margin for the Text Field.
//
//           If no right margin is required, set 'RightMarginStr'
//           to a zero length or empty string, and no right margin
//           will be created.
//
//         LineTerminator              string
//           This string holds the character or characters which
//           will be used to terminate the formatted line of text
//           output thereby converting this text element into a
//           valid line of text. Line Termination is optional.
//           Populate this string only if this text output should
//           be formatted as a separate line of text.
//
//           The most common usage sets this string to a new line
//           character ("\n"); however, any string of text
//           characters will be accepted.
//
//           If no Line Terminator is required, set
//           'LineTerminator' to a zero length or empty string and
//           no line termination characters will be created.
//
//         MaxLineLength               int
//           The maximum length of the line on which this label
//           text will be presented.
//
//           Set this parameter to minus one (-1) to specify an
//           unlimited line length for this text line.
//
//           'MaxLineLength' is used in conjunction with parameter
//           'TurnAutoLineLengthBreaksOn' to automatically place
//           text fields on separate text lines when that text
//           exceeds the maximum text line length('MaxLineLength').
//           Therefore, parameter 'turnAutoLineLengthBreaksOn'
//           controls whether automatic line breaks using
//           'MaxLineLength' will be applied.
//
//           If the value of 'MaxLineLength' is less than one (1),
//           it will be automatically converted to minus one (-1).
//
//           Set this parameter to minus one (-1) to specify an
//           unlimited line length for this text line.
//
//         TurnAutoLineLengthBreaksOn  bool
//           This parameter controls whether text lines which
//           exceed the maximum line length ('MaxLineLength') are
//           broken up and presented on the following line.
//
//           To apply automatic line breaking at the maximum line
//           length, set the value of this parameter to 'true'.
//
//       }
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted text
//       characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldLabelDto(
	textLabelDto TextFieldLabelDto,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldLabelDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(textLabelDto.FieldText) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textLabelDto.FieldText' is invalid!\n"+
			"'textLabelDto.FieldText' is an empty string with a\n"+
			"string length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	if textLabelDto.FieldLength < -1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'textLabelDto.FieldLength' is invalid!\n"+
			"'textLabelDto.FieldLength' has a value less than minus one (-1).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			textLabelDto.FieldLength)

		return strBuilder, err

	}

	return textStrBuilderAtom{}.ptr().buildLabelFieldWithDto(
		textLabelDto.CopyOut(),
		ePrefix.XCpy(
			"strBuilder<-textLabelDto"))
}

// FieldSpacer - Creates and formats a Text Spacer Field and writes
// the output string to an instance of strings.Builder which is
// returned to the calling function.
//
// Text Spacer Fields consist of one or more white space characters
// (" ").
//
// Text Spacer Field Example-1:
//
//  LeftMarginStr = ""
//  FieldLength = 3
//  RightMarginStr = ""
//  LineTerminator = ""
//  Final Text Spacer string = "   " // 3-white spaces
//
// Text Spacer Field Example-2:
//
//  LeftMarginStr = ""
//  FieldLength = 3
//  RightMarginStr = ""
//  LineTerminator = "\n"
//  Final Text Spacer string = "   \n" // 3-white spaces and
//                                     // 1-new line character
//                                     // ('\n')
//
// Typically, Text Spacer Fields are designed to be configured
// within a line of text. However, users have the option of
// configuring a Text Filler Field as a separate stand-alone
// line of text by configuring the input parameter
// 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of this string will be used as the left
//       margin for the Text Spacer Field.
//
//       If no left margin is required, set 'leftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  fieldLength                int
//     - An integer value used to specify the number of white space
//       characters in the Text Spacer Field.
//
//       If the value of this parameter is less than zero and greater
//       than one-million (1,000,000), an error will be returned.
//
//       Examples:
//        fieldLen = 1 produces text field " "  // 1-white space
//        fieldLen = 2 produces text field "  " // 2-white spaces
//        fieldLen = 5 produces text field "     " // 5-white spaces
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the text line
//       consists of the text spacer field and no other text
//       elements. Any string of text characters will be accepted
//       for this parameter.
//
//       Again, the most common usage sets this string to a new
//       line character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  maxLineLength              int
//     - The maximum length of the line on which this Text Spacer
//       Field will be presented.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       'maxLineLength' is used in conjunction with parameter
//       'turnAutoLineLengthBreaksOn' to automatically place text
//       fields on separate text lines when that text exceeds the
//       maximum text line length ('maxLineLength'). Therefore,
//       paramter 'turnAutoLineLengthBreaksOn' controls whether
//       automatic line breaks using 'maxLineLength' will be
//       applied.
//
//       If the value of 'maxLineLength' is less than one (1), it
//       will be automatically converted to minus one (-1).
//
//
//  turnAutoLineLengthBreaksOn bool
//     - This parameter controls whether text lines which exceed
//       the maximum line length ('maxLineLength') are broken up
//       and presented on the following line.
//
//       To apply automatic line breaking at the maximum line
//       length, set the value of this parameter to 'true'.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldSpacer(
	leftMarginStr string,
	fieldLength int,
	rightMarginStr string,
	lineTerminator string,
	maxLineLength int,
	turnAutoLineLengthBreaksOn bool,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldSpacer()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if fieldLength < 1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value less than one (1).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if fieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'fieldLength' is invalid!\n"+
			"'fieldLength' has a value greater than one-million (1,000,000).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			fieldLength)

		return strBuilder, err

	}

	if maxLineLength < 1 {
		maxLineLength = -1
	}

	txtFieldSpacerDto := TextFieldSpacerDto{
		FormatType:                 TxtFieldType.Spacer(),
		LeftMarginStr:              leftMarginStr,
		FieldLength:                fieldLength,
		RightMarginStr:             rightMarginStr,
		LineTerminator:             lineTerminator,
		MaxLineLength:              maxLineLength,
		TurnAutoLineLengthBreaksOn: turnAutoLineLengthBreaksOn,
		lock:                       nil,
	}

	return textStrBuilderAtom{}.ptr().
		buildSpacerFieldWithDto(
			txtFieldSpacerDto,
			ePrefix.XCpy(
				"strBuilder<-txtFieldSpacerDto"))
}

// FieldSpacerDto - Creates and formats a Text Spacer Field and
// writes the output string to an instance of strings.Builder which
// is returned to the calling function. This text label field is
// created from a Text Field Spacer Data Transfer Object
// (TextFieldSpacerDto) passed as an input parameter.
//
// Text Spacer Fields consist of one or more white space characters
// (" ").
//
// Text Spacer Field Example-1:
//
//  LeftMarginStr = ""
//  FieldLength = 3
//  RightMarginStr = ""
//  LineTerminator = ""
//  Final Text Spacer string = "   " // 3-white spaces
//
// Text Spacer Field Example-2:
//
//  LeftMarginStr = ""
//  FieldLength = 3
//  RightMarginStr = ""
//  LineTerminator = "\n"
//  Final Text Spacer string = "   \n" // 3-white spaces and
//                                     // 1-new line character
//                                     // ('\n')
//
// Typically, Text Spacer Fields are designed to be configured
// within a line of text. However, users have the option of
// configuring a Text Filler Field as a separate stand-alone
// line of text by configuring the input parameter
// 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  txtFieldSpacerDto          TextFieldSpacerDto
//     - An instance of TextFieldSpacerDto which contains all the
//       necessary data parameters to produce a Text Spacer Field.
//
//       The Text Field Spacer Data Transfer Object is defined as
//       follows:
//
//       type TextFieldSpacerDto struct {
//
//        FormatType                   TextFieldType
//         Required. This enumeration value specifies the type of
//         Text Format Operation to be performed.
//
//         For the TextFieldSpacerDto Format Type, this value
//         should always be set to: TxtFieldType.Spacer()
//
//        LeftMarginStr                string
//         The contents of the string will be used as the left
//         margin for the Text Spacer Field.
//
//         If no left margin is required, set 'leftMarginStr' to a
//         zero length or empty string, and no left margin will be
//         created.
//
//        FieldLength                  int
//         An integer value used to specify the number of white
//         space characters in the Text Spacer Field.
//
//         Values less than one (1) and greater than one million
//         (1,000,000) will generate errors.
//
//         Examples:
//          fieldLen = 1 produces text field " "
//              // 1-white space
//
//          fieldLen = 2 produces text field "  "
//             // 2-white spaces
//
//          fieldLen = 5 produces text field "     "
//             // 5-white spaces
//
//        RightMarginStr               string
//         The contents of the string will be used as the right
//         margin for the Text Spacer Field.
//
//         If no right margin is required, set 'rightMarginStr' to
//         a zero length or empty string, and no right margin will
//         be created.
//
//        LineTerminator               string
//         This string holds the character or characters which will
//         be used to terminate the formatted line of text output.
//
//         The most common usage sets this string to a new line
//         character ("\n").
//
//         If no Line Terminator is required, set 'lineTerminator'
//         to a zero length or empty string and no line
//         termination characters will be created.
//
//        MaxLineLength                int
//         The maximum length of the line on which this label text
//         will be presented.
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//         'MaxLineLength' is used in conjunction with parameter
//         'TurnAutoLineLengthBreaksOn' to automatically place text
//         fields on separate text lines when that text exceeds the
//         maximum text line length ('MaxLineLength'). Therefore,
//         paramter 'turnAutoLineLengthBreaksOn' controls whether
//         automatic line breaks using 'MaxLineLength' will be
//         applied.
//
//         If the value of 'maxLineLength' is less than one (1), it
//         will be automatically converted to minus one (-1).
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//        TurnAutoLineLengthBreaksOn   bool
//         This parameter controls whether text lines which exceed
//         the maximum line length ('MaxLineLength') are broken up
//         and presented on the following line.
//
//         To apply automatic line breaking at the maximum line
//         length, set the value of this parameter to 'true'.
//
//       }
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldSpacerDto(
	txtFieldSpacerDto TextFieldSpacerDto,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldSpacerDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if txtFieldSpacerDto.FieldLength < 1 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtFieldSpacerDto.FieldLength' is invalid!\n"+
			"'txtFieldSpacerDto.FieldLength' has a value less than one (1).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			txtFieldSpacerDto.FieldLength)

		return strBuilder, err

	}

	if txtFieldSpacerDto.FieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtFieldSpacerDto.FieldLength' is invalid!\n"+
			"'txtFieldSpacerDto.FieldLength' has a value greater than one-million (1,000,000).\n"+
			"fieldLength = '%v'\n",
			ePrefix.String(),
			txtFieldSpacerDto.FieldLength)

		return strBuilder, err

	}

	if txtFieldSpacerDto.MaxLineLength < 1 {
		txtFieldSpacerDto.MaxLineLength = -1
	}

	return textStrBuilderAtom{}.ptr().
		buildSpacerFieldWithDto(
			txtFieldSpacerDto,
			ePrefix.XCpy(
				"strBuilder<-txtFieldSpacerDto"))
}

// FieldsSingleLabel - Designed to produce three text elements
// consolidated and formatted as a single text field.
//
// The three text elements consist of a left margin string, a text
// label and a right margin string.
//
// These three text elements can be configured as a complete line
// of text depending on the value applied to input parameter
// 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of the string will be used as the left margin
//       for 'labelText field.
//
//       If no left margin is required, set 'LeftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  labelText                  string
//     - This strings holds the text characters which will be
//       formatted as a text label.
//
//       This text label will be positioned to the immediate
//       right of the left margin string, 'leftMarginStr'.
//
//       If 'labelText' is submitted as a zero length or empty
//       string, an error will be returned.
//
//
//  labelFieldLength           int
//     - Used to format the Text Label Field, 'labelText'. This is
//       the length of the text field in which the formatted
//       'labelText' string will be displayed. If
//       'labelFieldLength' is less than the length of the
//       'labelText' string, it will be automatically set equal to
//       the 'labelText' string length.
//
//       To automatically set the value of 'labelFieldLength' to
//       the length of 'labelText', set this parameter to a value
//       of  minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  labelTextJustify           TextJustify
//      An enumeration value specifying the justification of the
//      'labelText' string within the text field specified by
//      'labelFieldLength'.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  rightMarginStr             string
//     - The contents of the string will be used as the right
//       margin for the 'labelText' field.
//
//       If no right margin is required, set 'RightMarginStr' to a
//       zero length or empty string, and no right margin will be
//       created.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the three
//       text elements formatted by this method as single text
//       field will constitute a single line of text.
//
//       The most common usage sets this string to a new line
//       character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldsSingleLabel(
	leftMarginStr string,
	labelText string,
	labelFieldLength int,
	labelTextJustify TextJustify,
	rightMarginStr string,
	lineTerminator string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldsSingleLabel()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(labelText) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'labelText' is invalid!\n"+
			"'labelText' is an empty string with a string length\n"+
			"of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	return textStrBuilderAtom{}.ptr().fieldLabelWithMargins(
		leftMarginStr,
		labelText,
		labelFieldLength,
		labelTextJustify,
		rightMarginStr,
		lineTerminator,
		ePrefix.XCpy(
			"strBuilder<-labelText"))
}

// FieldsSingleSpacer - Designed to produce three text elements
// consolidated and formatted as a single text field.
//
// The three text elements consist of a left margin string, a Text
// Spacer Field and a right margin string.
//
// These three text elements can be configured as a complete line
// of text depending on the value applied to input parameter
// 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of the string will be used as the left margin
//       for 'labelText field.
//
//       If no left margin is required, set 'LeftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  fieldLength                int
//     - An integer value which is used to specify the number of
//       white space characters (" ") in the Text Spacer Field.
//
//       Examples:
//          fieldLen = 1 produces text field " "
//          fieldLen = 2 produces text field "  "
//          fieldLen = 5 produces text field "     "
//
//        If the value of 'fieldLength' is less than 1 or greater
//        than one-million, an error will be returned.
//
//
//  rightMarginStr             string
//     - The contents of the string will be used as the right
//       margin for the 'labelText' field.
//
//       If no right margin is required, set 'RightMarginStr' to a
//       zero length or empty string, and no right margin will be
//       created.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       this text element into a valid line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the three
//       text elements formatted by this method as single text
//       field will constitute a single line of text.
//
//       The most common usage sets this string to a new line
//       character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing formatted
//       text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldsSingleSpacer(
	leftMarginStr string,
	fieldLength int,
	rightMarginStr string,
	lineTerminator string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldSpacer()",
		"")

	if err != nil {
		return strBuilder, err
	}

	return textStrBuilderElectron{}.ptr().
		fieldSpacerWithMargins(
			leftMarginStr,
			fieldLength,
			rightMarginStr,
			lineTerminator,
			ePrefix.XCpy(
				"strBuilder<-Spacer FieldLength"))
}

// FieldsLabelParameterValue - Is designed to five text elements
// consolidated and formatted as a single text field.
//
// The five text elements consist of a left margin string, a
// parameter text label field, a parameter label right margin
// string, a parameter value label field, and a parameter value
// right margin string.
//
// These five text elements can be configured as a complete line of
// text depending on the value applied to input parameter
// 'lineTerminator'.
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The contents of the string will be used as the left margin
//       for the 'paramLabelStr' field.
//
//       If no left margin is required, set 'LeftMarginStr' to a
//       zero length or empty string, and no left margin will be
//       created.
//
//
//  paramLabelStr              string
//     - This strings holds the text characters which will be
//       formatted as a Parameter Text Label. The 'paramLabelStr'
//       field provides a text description of the Parameter Value
//       field, 'paramValueStr'.
//
//       This text label, 'paramLabelStr', will be positioned to
//       the immediate right of the left margin string,
//       'leftMarginStr'.
//
//       If 'paramLabelStr' is submitted as a zero length or empty
//       string, it will be skipped or ignored and no error will be
//       generated.
//
//
//  paramLabelFieldLength      int
//     - Used to format the Text Label Field, 'paramLabelStr'. This
//       is the length of the text field in which the formatted
//       'paramLabelStr' string will be displayed. If
//       'paramLabelFieldLength' is less than the length of the
//       'paramLabelStr' string, it will be automatically set equal
//       to the 'paramLabelStr' string length.
//
//       To automatically set the value of 'paramLabelFieldLength'
//       to the length of 'paramLabelStr', set this parameter to a
//       value of  minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  paramLabelTextJustify      TextJustify
//      An enumeration value specifying the justification of the
//      'paramLabelStr' string within the text field specified by
//      'paramLabelFieldLength'.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  paramLabelRightMarginStr   string
//     - The contents of the string will be used as the right
//       margin for the 'paramLabelStr' field.
//
//       If no right margin is required, set
//       'paramLabelRightMarginStr' to a zero length or empty
//       string, and no right margin will be created.
//
//
//  paramValueStr              string
//     - This strings holds the text characters which will be
//       formatted as a Parameter Text Label. The 'paramValueStr'
//       field contains actual Parameter Value information.
//
//       This text label will be positioned to the immediate
//       right of the Parameter Label Right Margin string,
//       'paramLabelRightMarginStr'.
//
//       If 'paramValueStr' is submitted as a zero length or empty
//       string, an error will be returned.
//
//
//  paramValueFieldLength      int
//     - Used to format the Text Label Field, 'paramValueStr'. This
//       is the length of the text field in which the formatted
//       'paramValueStr' string will be displayed. If
//       'paramValueFieldLength' is less than the length of the
//       'paramValueStr' string, it will be automatically set equal
//       to the 'paramValueStr' string length.
//
//       To automatically set the value of 'paramValueFieldLength'
//       to the length of 'paramValueStr', set this parameter to a
//       value of minus one (-1).
//
//       If this parameter is submitted with a value less than
//       minus one (-1) or greater than 1-million (1,000,000), an
//       error will be returned.
//
//
//  paramValueTextJustify      TextJustify
//      An enumeration value specifying the justification of the
//      'paramValueStr' string within the text field specified by
//      'paramValueFieldLength'.
//
//      Text justification can only be evaluated in the context of
//      a text label, field length and a Text Justification object
//      of type TextJustify. This is because text labels with a
//      field length equal to or less than the length of the text
//      label never use text justification. In these cases, text
//      justification is completely ignored.
//
//      If the field length is greater than the length of the text
//      label, text justification must be equal to one of these
//      three valid values:
//          TextJustify(0).Left()
//          TextJustify(0).Right()
//          TextJustify(0).Center()
//
//      You can also use the abbreviated text justification
//      enumeration syntax as follows:
//
//          TxtJustify.Left()
//          TxtJustify.Right()
//          TxtJustify.Center()
//
//
//  paramValueRightMarginStr   string
//     - The contents of the string will be used as the right
//       margin for the 'paramValueStr' field.
//
//       If no right margin is required, set
//       'paramValueRightMarginStr' to a zero length or empty
//       string, and no right margin will be created.
//
//
//  lineTerminator             string
//     - This string holds the character or characters which will
//       be used to terminate the formatted text thereby converting
//       these five text element into a single line of text.
//
//       If a text line is required, setting this string to include
//       a new line character ('\n') will ensure that the five text
//       elements formatted by this method as single text field
//       will constitute a single line of text.
//
//       The most common usage sets this string to a new line
//       character ("\n").
//
//       If Line Termination is NOT required, set 'lineTerminator'
//       to a zero length or empty string and no line termination
//       characters will be created.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  err                        error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) FieldsLabelParameterValue(
	leftMarginStr string,
	paramLabelStr string,
	paramLabelFieldLength int,
	paramLabelTextJustify TextJustify,
	paramLabelRightMarginStr string,
	paramValueStr string,
	paramValueFieldLength int,
	paramValueTextJustify TextJustify,
	paramValueRightMarginStr string,
	lineTerminator string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"FieldsLabelParameterValue()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(paramValueStr) == 0 {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'paramValueStr' is invalid!\n"+
			"'paramValueStr' is an empty string with a string\n"+
			"length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	txtBuilderAtom := textStrBuilderAtom{}

	strBuilder,
		err = txtBuilderAtom.fieldLabelWithMargins(
		leftMarginStr,
		paramLabelStr,
		paramLabelFieldLength,
		paramLabelTextJustify,
		paramLabelRightMarginStr,
		"",
		ePrefix.XCpy(
			"strBuilder<-paramLabelStr"))

	if err != nil {
		return strBuilder, err
	}

	var strBuilder2 strings.Builder

	strBuilder2,
		err = txtBuilderAtom.fieldLabelWithMargins(
		"",
		paramValueStr,
		paramValueFieldLength,
		paramValueTextJustify,
		paramValueRightMarginStr,
		lineTerminator,
		ePrefix.XCpy(
			"strBuilder<-paramValueStr"))

	strBuilder.WriteString(strBuilder2.String())

	strBuilder2.Reset()

	return strBuilder, err
}

// LineBlank - Formats one or more blank or empty lines and writes
// the output string to an instances of strings.Builder which is
// returned to the calling function.
//
// Blank Lines typically consist of one or more new line characters
// ('\n') and nothing more. However, users have the option to
// provide alternate or custom line termination characters which
// will be applied instead.
//
// The number of blank lines created is controlled by input
// parameter 'numOfBlankLines'.
//
//  Example-1 :
//   NumOfBlankLines = 3
//   LineTerminator = ""
//   Final Blank Line Text = "\n\n\n" // 3-new line characters
//
//  Example-2 :
//   NumOfBlankLines = 2
//   LineTerminator = "\n x \n"
//   Final Blank Line Text = "\n x \n\n x \n"
//
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  numOfBlankLines            int
//     - Specifies the number of blank lines which will be created.
//       Essentially, this parameter controls the number of new
//       line characters, or line terminators, configured in the
//       resulting text string.
//
//       If this parameter is submitted with a value less than one
//       (1), it will be converted to one (1).
//
//       If this paramter is submitted with a value greater than
//       one-million (1,000,000), an error will be returned.
//
//
//  lineTerminator             string
//     - If this parameter is submitted as an empty string,
//       the default new line terminator ('\n') will be applied as
//       a line termination sequence.
//
//       If this parameter is populated, this character sequence
//       will be used as the Line Terminator for this text blank
//       line.
//
//
//  errorPrefix                     interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) LineBlank(
	numOfBlankLines int,
	lineTerminator string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"LineBlank()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if numOfBlankLines < 1 {

		numOfBlankLines = 1

	}

	if numOfBlankLines > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'numOfBlankLines' is invalid!\n"+
			"'numOfBlankLines' has a value greater than one-million (1,000,000).\n"+
			"numOfBlankLines = '%v'\n",
			ePrefix.String(),
			numOfBlankLines)

		return strBuilder, err

	}

	txtLineBlankDto := TextLineBlankDto{
		FormatType:      TxtFieldType.BlankLine(),
		NumOfBlankLines: numOfBlankLines,
		LineTerminator:  lineTerminator,
		lock:            nil,
	}

	return textStrBuilderAtom{}.ptr().buildTextLineBlankWithDto(
		txtLineBlankDto,
		ePrefix.XCpy(fmt.Sprintf(
			"strBuilder<-txtLineBlankDto blank lines =='%v'",
			numOfBlankLines)))
}

// LineBlankDto - Formats one or more blank or empty lines and
// writes the output string to an instances of strings.Builder
// which is returned to the calling function.
//
// Blank Lines typically consist of one or more new line characters
// ('\n') and nothing more. However, users have the option to
// provide alternate or custom line termination characters which
// will be applied instead.
//
// The number of blank lines created is controlled by input
// parameter 'numOfBlankLines'.
//
//  Example-1 :
//   NumOfBlankLines = 3
//   LineTerminator = ""
//   Final Blank Line Text = "\n\n\n" // 3-new line characters
//
//  Example-2 :
//   NumOfBlankLines = 2
//   LineTerminator = "\n x \n"
//   Final Blank Line Text = "\n x \n\n x \n"
//
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  numOfBlankLines            int
//     - Specifies the number of blank lines which will be created.
//       Essentially, this parameter controls the number of new
//       line characters, or line terminators, configured in the
//       resulting text string.
//
//       If this parameter is submitted with a value less than one
//       (1), it will be converted to one (1).
//
//       If this paramter is submitted with a value greater than
//       one-million (1,000,000), an error will be returned.
//
//
//  lineTerminator             string
//     - If this parameter is submitted as an empty string,
//       the default new line terminator ('\n') will be applied as
//       a line termination sequence.
//
//       If this parameter is populated, this character sequence
//       will be used as the Line Terminator for this text blank
//       line.
//
//
//  errorPrefix                     interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered, this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) LineBlankDto(
	txtLineBlankDto TextLineBlankDto,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"LineBlankDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if txtLineBlankDto.NumOfBlankLines < 1 {

		txtLineBlankDto.NumOfBlankLines = 1

	}

	if txtLineBlankDto.NumOfBlankLines > 1000000 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtLineBlankDto.NumOfBlankLines' is invalid!\n"+
			"'txtLineBlankDto.NumOfBlankLines' has a value greater than one-million (1,000,000).\n"+
			"txtLineBlankDto.NumOfBlankLines = '%v'\n",
			ePrefix.String(),
			txtLineBlankDto.NumOfBlankLines)

		return strBuilder, err

	}

	return textStrBuilderAtom{}.ptr().buildTextLineBlankWithDto(
		txtLineBlankDto,
		ePrefix.XCpy(fmt.Sprintf(
			"strBuilder<-txtLineBlankDtoDto blank lines =='%v'",
			txtLineBlankDto.NumOfBlankLines)))
}

// LineSolid - Formats a single Solid Text Line and writes the
// output string to an instance of strings.Builder which is
// returned to the calling function.
//
// A solid line, as defined here, consists of a single character or
// multiple characters used in a repeating sequence to construct
// a solid line. Typically, solid lines consist of dashes ("---"),
// underscore characters ("____"), equal signs ("====="), asterisks
// ("*****") and other similar line break presentations. Multiple
// characters may be used to produce more complex line sequences
// ("--*--*--*"). The length of a solid line is specified by
// input parameter, 'SolidLineCharRepeatCount'.
//
// Therefore, the number of solid line characters produced is
// equal to:
//   (Number of  solid line characters 'solidLineChars')
//        x 'solidLineCharRepeatCount'
//
// By default, all solid lines are terminated with a new line
// character ('\n'). This means that each instance of a solid line
// will be formatted as a single line of text. Users have the
// option to alter this behavior and control the content and
// application of line termination characters through two input
// parameters, 'turnLineTerminationOff' and 'lineTerminator'.
//
//       Example-1:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = false
//         LineTerminator = ""
//         Final Solid Line String = "*****\n"
//
//       Example-2:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = false
//         LineTerminator = "\n\n"
//         Final Solid Line String = "*****\n\n"
//
//       Example-3:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = true
//         LineTerminator = "\n\n"
//         Final Solid Line String = "*****"
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - A string containing the text characters to be positioned
//       on the Left side of the Solid Line.
//
//       If no Left margin is required, set this parameter to an
//       empty string ("").
//
//       Example A-1:
//         LeftMarginStr = "xxx"
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         RightMarginStr = "" // Empty string
//         Solid Line = "xxx*****"
//
//       Example A-2:
//         LeftMarginStr = ""
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         RightMarginStr = "" // Empty string
//         Solid Line = "*****"
//
//       If the 'LeftMarginStr' string length is greater than
//       one-million (1,000,000), an error will be returned when
//       attempting to create formatted text output.
//
//
//  solidLineChars             string
//     - This string specifies the character or characters which
//       will comprise the solid line string for screen display,
//       file output or printing.
//
//       Example B-1:
//         solidLineChars = "*"
//         solidLineCharsRepeatCount = 5
//         Solid line = "*****"
//
//       If this parameter is submitted as a zero length string, an
//       error will be returned.
//
//
//  solidLineCharRepeatCount   int
//     - This integer value specifies the number of times that
//       parameter 'solidLineChars' will be repeated in
//       constructing the solid line.
//
//       If this parameter is submitted with a value less than one
//       (1), it will be automatically converted to one (1).
//
//       Example C-1:
//         solidLineChars = "*"
//         solidLineCharsRepeatCount = 5
//         Solid line = "*****"
//
//
//  rightMarginStr             string
//     - A string containing the text characters to positioned on
//       the Right side of the Solid Line.
//
//       If no Right margin is required, set this parameter to an
//       empty string.
//
//       Example D-1:
//         solidLineChars = "*"
//         solidLineCharsRepeatCount = 5
//         leftMarginStr = "" // Empty string
//         RightMarginStr = "xxx"
//         Solid line = "*****xxx"
//
//       If the 'RightMarginStr' string length is greater than
//       one-million (1,000,000), an error will be returned when
//       attempting to created formatted text output.
//
//
//  turnLineTerminationOff     bool
//     - If this parameter is set to 'true' no Line Termination
//       Sequence will be applied for this text line (Example E-3).
//
//             Example E-1:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = false
//               LineTerminator = ""
//               Final Solid Line String = "*****\n"
//
//             Example E-2:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = false
//               LineTerminator = "\n\n"
//               Final Solid Line String = "*****\n\n"
//
//             Example E-3:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = true
//               LineTerminator = "\n\n"
//               Final Solid Line String = "*****"
//
//
//  lineTerminator             string
//     - This string holds the character or characters which
//       will be used to terminate the formatted line of text
//       output.
//
//       The most common usage sets this string to a new line
//       character ("\n").
//
//       If 'LineTerminator' is configured as an empty string
//       (string length zero), a single new line character ('\n')
//       will be automatically applied to produce line termination.
//
//       LineTerminator works in conjunction with member variable
//       'TurnLineTerminationOff'. 'TurnLineTerminationOff'
//       controls the application of a line terminator. Setting
//       'TurnLineTerminationOff' to 'true' means that NO line
//       terminator will be applied to this instance of Text Solid
//       Line (Example F-3).
//
//             Example F-1:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = false
//               LineTerminator = ""
//               Final Solid Line String = "*****\n"
//
//             Example F-2:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = false
//               LineTerminator = "\n\n"
//               Final Solid Line String = "*****\n\n"
//
//             Example F-3:
//               SolidLineChars = "*"
//               SolidLineCharRepeatCount = 5
//               LeftMarginStr = ""
//               RightMarginStr = ""
//               TurnLineTerminationOff = true
//               LineTerminator = "\n\n"
//               Final Solid Line String = "*****"
//
//
//  maxLineLength              int
//     - The maximum length of the line on which the solid line
//       text characters will be presented.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       'maxLineLength' is used in conjunction with parameter
//       'turnAutoLineLengthBreaksOn' to automatically place text
//       fields on separate text lines when that text exceeds the
//       maximum text line length ('maxLineLength'). Therefore,
//       paramter 'turnAutoLineLengthBreaksOn' controls whether
//       automatic line breaks using 'maxLineLength' will be
//       applied.
//
//       Set this parameter to minus one (-1) to specify an
//       unlimited line length for this text line.
//
//       If the value of 'maxLineLength' is less than one (1),
//       it will be automatically converted to minus one (-1).
//
//
//  turnAutoLineLengthBreaksOn bool
//     - This parameter controls whether text lines which exceed
//       the maximum line length ('maxLineLength') are positioned
//       on the following line as a separate line of text.
//
//       To apply automatic line breaking at the maximum line
//       length ('maxLineLength'), set the value of this parameter
//       to 'true'.
//
//       When this parameter is set to 'true', text fields which
//       extend beyond the maximum line length ('maxLineLength')
//       will be formatted as a separate line of text on the
//       following line.
//
//
//  errorPrefix                interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) LineSolid(
	leftMarginStr string,
	solidLineChars string,
	solidLineCharRepeatCount int,
	rightMarginStr string,
	turnLineTerminationOff bool,
	lineTerminator string,
	maxLineLength int,
	turnAutoLineLengthBreaksOn bool,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"LineSolid()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(solidLineChars) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'solidLineChars' is invalid!\n"+
			"'solidLineChars' is an empty string with a string\n"+
			"length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	if solidLineCharRepeatCount < 1 {

		solidLineCharRepeatCount = 1
	}

	if maxLineLength < 1 {

		maxLineLength = -1
	}

	txtLineSolidDto := TextLineSolidDto{
		FormatType:                 TxtFieldType.SolidLine(),
		LeftMarginStr:              leftMarginStr,
		SolidLineChars:             solidLineChars,
		SolidLineCharRepeatCount:   solidLineCharRepeatCount,
		RightMarginStr:             rightMarginStr,
		TurnLineTerminationOff:     turnLineTerminationOff,
		LineTerminator:             lineTerminator,
		MaxLineLength:              maxLineLength,
		TurnAutoLineLengthBreaksOn: turnAutoLineLengthBreaksOn,
		lock:                       nil,
	}

	return textStrBuilderAtom{}.ptr().buildTextLineSolidWithDto(
		txtLineSolidDto,
		ePrefix.XCpy(
			"strBuilder<-fillerCharacters"))

}

// LineSolidDto - Formats a single Solid Text Line and writes the
// output string to an instance of strings.Builder which is
// returned to the calling function. This Solid Text Line string is
// created from a Text Line Sold Data Transfer Object
// (TextLineSolidDto) passed as an input parameter.
//
// A solid line, as defined here, consists of a single character or
// multiple characters used in a repeating sequence to construct
// a solid line. Typically, solid lines consist of dashes ("---"),
// underscore characters ("____"), equal signs ("====="), asterisks
// ("*****") and other similar line break presentations. Multiple
// characters may be used to produce more complex line sequences
// ("--*--*--*"). The length of a solid line is specified by
// input parameter, 'SolidLineCharRepeatCount'.
//
// Therefore, the number of solid line characters produced is
// equal to:
//   (Number of  solid line characters 'solidLineChars')
//        x 'solidLineCharRepeatCount'
//
// By default, all solid lines are terminated with a new line
// character ('\n'). This means that each instance of a solid line
// will be formatted as a single line of text. Users have the
// option to alter this behavior and control the content and
// application of line termination characters through two input
// parameters, 'turnLineTerminationOff' and 'lineTerminator'.
//
//       Example-1:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = false
//         LineTerminator = ""
//         Final Solid Line String = "*****\n"
//
//       Example-2:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = false
//         LineTerminator = "\n\n"
//         Final Solid Line String = "*****\n\n"
//
//       Example-3:
//         SolidLineChars = "*"
//         SolidLineCharRepeatCount = 5
//         LeftMarginStr = ""
//         RightMarginStr = ""
//         TurnLineTerminationOff = true
//         LineTerminator = "\n\n"
//         Final Solid Line String = "*****"
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  txtLineSolidDto            TextLineSolidDto
//     - An instance of TextLineSolidDto which contains all the
//       data parameters required to produce a Text Solid Line.
//
//       The Text Line Solid Transfer Object is defined as
//       follows:
//       type TextLineSolidDto struct {
//
//        FormatType                   TextFieldType
//         Required. This enumeration value specifies the type of
//         Text Format Operation to be performed.
//
//         For TextLineSolidDto 'FormatType' this parameter should
//         be set to: TxtFieldType.SolidLine()
//
//        LeftMarginStr                string
//         A string containing the text characters to be positioned
//         on the Left side of the Solid Line.
//
//         If no Left margin is required, set this parameter to an
//         empty string.
//
//         Example:
//           LeftMarginStr = "xxx"
//           SolidLineChars = "*"
//           SolidLineCharRepeatCount = 5
//           RightMarginStr = "" // Empty string
//           Solid Line = "xxx*****"
//
//         If the 'LeftMarginStr' string length is greater than
//         one-million (1,000,000), an error will be returned when
//         attempting to create formatted text output.
//
//        SolidLineChars               string
//         This string specifies the character or characters which
//         will comprise the solid line string for screen display,
//         file output or printing.
//
//         Example:
//           solidLineChars = "*"
//           solidLineCharsRepeatCount = 5
//           Solid line = "*****"
//
//         If this parameter is submitted as a zero length string,
//         an error will be returned when attempting to create
//         formatted.
//
//        SolidLineCharRepeatCount     int
//         This integer value specifies the number of times that
//         parameter 'solidLineChars' will be repeated in
//         constructing the solid line.
//
//       If this parameter is submitted with a value less than one
//       (1), it will be automatically converted to one (1).
//
//         Example:
//           solidLineChars = "*"
//           solidLineCharsRepeatCount = 5
//           Solid line = "*****"
//
//        RightMarginStr               string
//         A string containing the text characters to positioned on
//         the Right side of the Solid Line.
//
//         If no Right margin is required, set this parameter to an
//         empty string.
//
//         Example:
//           solidLineChars = "*"
//           solidLineCharsRepeatCount = 5
//           leftMarginStr = "" // Empty string
//           RightMarginStr = "xxx"
//           Solid line = "*****xxx"
//
//         If the 'RightMarginStr' string length is greater than
//         one-million (1,000,000), an error will be returned.
//
//        TurnLineTerminationOff     bool
//         If this parameter is set to 'true' no Line Termination
//         Sequence will be applied for this text line (Example-3).
//
//              Example-1:
//                SolidLineChars = "*"
//                SolidLineCharRepeatCount = 5
//                LeftMarginStr = ""
//                RightMarginStr = ""
//                TurnLineTerminationOff = false
//                LineTerminator = ""
//                Final Solid Line String = "*****\n"
//
//              Example-2:
//                SolidLineChars = "*"
//                SolidLineCharRepeatCount = 5
//                LeftMarginStr = ""
//                RightMarginStr = ""
//                TurnLineTerminationOff = false
//                LineTerminator = "\n\n"
//                Final Solid Line String = "*****\n\n"
//
//              Example-3:
//                SolidLineChars = "*"
//                SolidLineCharRepeatCount = 5
//                LeftMarginStr = ""
//                RightMarginStr = ""
//                TurnLineTerminationOff = true
//                LineTerminator = "\n\n"
//                Final Solid Line String = "*****"
//
//        LineTerminator               string
//         This string holds the character or characters which
//         will be used to terminate the formatted line of text
//         output.
//
//         The most common usage sets this string to a new line
//         character ("\n").
//
//         If 'LineTerminator' is configured as an empty string
//         (string length zero), a single new line character ('\n')
//         will be automatically applied to produce line termination.
//
//         LineTerminator works in conjunction with member variable
//         'TurnLineTerminationOff'. 'TurnLineTerminationOff'
//         controls the application of a line terminator. Setting
//         'TurnLineTerminationOff' to 'true' means that NO line
//         terminator will be applied to this instance of Text Solid
//         Line.
//
//               Example-1:
//                 SolidLineChars = "*"
//                 SolidLineCharRepeatCount = 5
//                 LeftMarginStr = ""
//                 RightMarginStr = ""
//                 TurnLineTerminationOff = false
//                 LineTerminator = ""
//                 Final Solid Line String = "*****\n"
//
//               Example-2:
//                 SolidLineChars = "*"
//                 SolidLineCharRepeatCount = 5
//                 LeftMarginStr = ""
//                 RightMarginStr = ""
//                 TurnLineTerminationOff = false
//                 LineTerminator = "\n\n"
//                 Final Solid Line String = "*****\n\n"
//
//               Example-3:
//                 SolidLineChars = "*"
//                 SolidLineCharRepeatCount = 5
//                 LeftMarginStr = ""
//                 RightMarginStr = ""
//                 TurnLineTerminationOff = true
//                 LineTerminator = "\n\n"
//                 Final Solid Line String = "*****"
//
//        MaxLineLength                int
//         The maximum length of the line on which the solid line
//         text characters will be presented.
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//         'MaxLineLength' is used in conjunction with parameter
//         'TurnAutoLineLengthBreaksOn' to automatically place text
//         fields on separate text lines when that text exceeds the
//         maximum text line length ('MaxLineLength'). Therefore,
//         paramter 'TurnAutoLineLengthBreaksOn' controls whether
//         automatic line breaks using 'MaxLineLength' will be
//         applied.
//
//         Set this parameter to minus one (-1) to specify an
//         unlimited line length for this text line.
//
//         If the value of 'MaxLineLength' is less than one (1),
//         it will be automatically converted to minus one (-1).
//
//         TurnAutoLineLengthBreaksOn   bool
//         This parameter controls whether text lines which exceed
//         the maximum line length ('MaxLineLength') are
//         positioned on the following line as a separate line of
//         text.
//
//         To apply automatic line breaking at the maximum line
//         length, set the value of this parameter to 'true'.
//
//         When this parameter is set to 'true', text fields which
//         extend beyond the maximum line length 'MaxLineLength'
//         will be formatted as a separate line of text on the
//         following line.
//
//       }
//
//
//  errorPrefix                       interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  strings.Builder
//     - If this method completes successfully, an instance of
//       strings.Builder will be returned containing a formatted
//       string of text characters.
//
//
//  error
//     - If this method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) LineSolidDto(
	txtLineSolidDto TextLineSolidDto,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(128)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"LineSolidDto()",
		"")

	if err != nil {
		return strBuilder, err
	}

	if len(txtLineSolidDto.SolidLineChars) == 0 {

		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'txtLineSolidDto.SolidLineChars' is invalid!\n"+
			"'txtLineSolidDto.SolidLineChars' is an empty string with a string\n"+
			"length of zero (0).\n",
			ePrefix.String())

		return strBuilder, err
	}

	if txtLineSolidDto.SolidLineCharRepeatCount < 1 {

		txtLineSolidDto.SolidLineCharRepeatCount = 1
	}

	if txtLineSolidDto.MaxLineLength < 1 {

		txtLineSolidDto.MaxLineLength = -1
	}

	return textStrBuilderAtom{}.ptr().buildTextLineSolidWithDto(
		txtLineSolidDto,
		ePrefix.XCpy(
			"strBuilder<-fillerCharacters"))

}

// LineTimerStartStop - Creates and returns a new instance of
// the Start/Stop Time Lines which is configured with all the
// parameters necessary to format and output a complete timer
// event.
//
// The purpose of the Start/Stop Time Lines text display is to
// capture all the essential elements of a timer event and
// format that information for text display, file output or
// printing.
//
// This method is designed to be used when both start time and
// ending time for the timer event are known quantities.
//
// Sample Output
//
//    Start Time: 2021-08-13 03:19:32.462108100 -0500 CDT
//      End Time: 2021-08-13 03:19:32.462163100 -0500 CDT
//  Elapsed Time: 55 Microseconds 0 Nanoseconds
//                Total Elapsed Nanoseconds: 55,000
//
//
// ----------------------------------------------------------------
//
// Input Parameters
//
//  leftMarginStr              string
//     - The character or characters which will comprise the left
//       margin of the text label.
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//       If leftMarginStr is submitted as an empty or zero length
//       string, no error will be triggered and the left margin
//       will simply be omitted.
//
//
//  startTimeLabel             string
//     - A string containing the text characters constituting the
//       starting time text label.
//
//       If this string is submitted as a zero length or empty
//       string, 'startTimeLabel' will be assigned a default value
//       of "Start Time".
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//
//  startTime                  time.Time
//     - A time value which will be used in conjunction with
//       'endTime' parameter to compute the time duration or
//       elapsed for the timer event.
//
//       If this parameter is submitted as a zero time value,
//       'startTime' will be defaulted to value of July 4, 1776
//       9:30AM UTC.
//
//
//  endTimeLabel               string
//     - A string containing the text characters constituting the
//       ending time text label.
//
//       If this string is submitted as a zero length or empty
//       string, 'endTimeLabel' will be assigned a default value of
//       "End Time".
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//
//  endTime                    time.Time
//     - A time value which will be used in conjunction with
//       'startTime' parameter to compute the time duration or
//       elapsed for the timer event.
//
//       If this parameter is submitted as a zero time value,
//       'endTime' will be defaulted to value of 'startTime'.
//
//
//  timeFormat                 string
//     - This string holds the time format parameters used to
//       format starting time and ending time values for text
//       display and output.
//
//       If this parameter is submitted as an empty string,
//       parameter 'timeFormat' will be assigned a default value
//       of "2006-01-02 15:04:05.000000000 -0700 MST"
//
//
//  timeDurationLabel          string
//     - The text label used to describe the time duration or
//       elapsed time computed from the 'startTime' and 'endTime'
//       parameters.
//
//       If this string is submitted as a zero length or empty
//       string, 'timeDurationLabel' will be assigned a default
//       value of "Elapsed Time".
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//
//  textLabelFieldLen          int
//     - A user entered value which defines the length of the text
//       field used by all three text labels, 'startTimeLabel',
//       'endTimeLabel' and 'timeDurationLabel'.
//
//       The length of the text fields which will be used to
//       position and display the three text labels provided by
//       input parameters 'startTimeLabel', 'endTimeLabel' and
//       'timeDurationLabel'.
//
//       If 'textLabelFieldLen' is less than the length of the
//       longest text label it will be defaulted to the length
//       of the longest text label ('startTimeLabel',
//       'endTimeLabel' or 'timeDurationLabel').
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//
//  textLabelJustification         TextJustify
//     - An enumeration which specifies the justification of the
//       three text labels 'startTimeLabel', 'endTimeLabel' and
//       'timeDurationLabel' within the field length specified by
//       'textLabelFieldLen'.
//
//       Label justification must be equal to one of these three
//       valid values:
//           TextJustify(0).Left()
//           TextJustify(0).Right()
//           TextJustify(0).Center()
//
//       The abbreviated text justification enumeration syntax can
//       also be used:
//
//           TxtJustify.Left()
//           TxtJustify.Right()
//           TxtJustify.Center()
//
//
//  rightMarginStr      string
//     - This string contains the character or characters which
//       will be used to separate the text labels ('startTimeLabel',
//       'endTimeLabel' and 'timeDurationLabel') from the output or
//       data values displayed on the same line.
//       Example:
//        Start Time[right margin chars]2010-01-02 15:04:05.000000000 -0700 MST
//
//       Often this parameter is set to a single white space
//       character (" ") or a colon plus white space character,
//       (": ").
//
//       If this string is submitted as a zero length or empty
//       string, 'rightMarginStr' will be assigned a
//       default value of  ": ". Example Output:
//        Start Time: 2010-01-02 15:04:05.000000000 -0700 MST
//
//       If the string length of 'leftMarginStr' plus
//       'rightMarginStr' plus the text label field length
//       ('textLabelFieldLen') exceeds the maximum length of
//       55-characters, this method will return an error.
//
//       If leftMarginStr is submitted as a zero length
//       string, no error will be triggered. In this case, the left
//       margin will simply be omitted.
//
//
//  errorPrefix                     interface{}
//     - This object encapsulates error prefix text which is
//       included in all returned error messages. Usually, it
//       contains the name of the calling method or methods
//       listed as a method or function chain of execution.
//
//       If no error prefix information is needed, set this
//       parameter to 'nil'.
//
//       This empty interface must be convertible to one of the
//       following types:
//
//
//       1. nil - A nil value is valid and generates an empty
//                collection of error prefix and error context
//                information.
//
//       2. string - A string containing error prefix information.
//
//       3. []string A one-dimensional slice of strings containing
//                   error prefix information
//
//       4. [][2]string A two-dimensional slice of strings
//          containing error prefix and error context information.
//
//       5. ErrPrefixDto - An instance of ErrPrefixDto. The
//                         ErrorPrefixInfo from this object will be
//                         copied to 'errPrefDto'.
//
//       6. *ErrPrefixDto - A pointer to an instance of
//                          ErrPrefixDto. ErrorPrefixInfo from this
//                          object will be copied to 'errPrefDto'.
//
//       7. IBasicErrorPrefix - An interface to a method generating
//                              a two-dimensional slice of strings
//                              containing error prefix and error
//                              context information.
//
//       If parameter 'errorPrefix' is NOT convertible to one of
//       the valid types listed above, it will be considered
//       invalid and trigger the return of an error.
//
//       Types ErrPrefixDto and IBasicErrorPrefix are included in
//       the 'errpref' software package,
//       "github.com/MikeAustin71/errpref".
//
//
// ----------------------------------------------------------------
//
// Return Values
//
//  *TextLineSpecTimerLines
//     - If this method completes successfully, it will create and
//       return a pointer to a new instance of
//       TextLineSpecTimerLines which is fully configured with all
//       the parameters necessary to format a complete timer event
//       for text display, file output or printing.
//
//
//  error
//     - If the method completes successfully and no errors are
//       encountered this return value is set to 'nil'. Otherwise,
//       if errors are encountered, this return value will contain
//       an appropriate error message.
//
//       If an error message is returned, the text value of input
//       parameter 'errorPrefix' will be inserted or prefixed at
//       the beginning of the error message.
//
func (txtStrBuildr *TextStrBuilder) LineTimerStartStop(
	leftMarginStr string,
	startTimeLabel string,
	startTime time.Time,
	endTimeLabel string,
	endTime time.Time,
	timeFormat string,
	timeDurationLabel string,
	textLabelFieldLen int,
	textLabelJustification TextJustify,
	rightMarginStr string,
	errorPrefix interface{}) (
	strings.Builder,
	error) {

	if txtStrBuildr.lock == nil {
		txtStrBuildr.lock = new(sync.Mutex)
	}

	txtStrBuildr.lock.Lock()

	defer txtStrBuildr.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var strBuilder strings.Builder

	strBuilder.Grow(1024)

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextStrBuilder."+
			"LineTimerStartStop()",
		"")

	if err != nil {
		return strBuilder, err
	}

	var timerLinesSpec *TextLineSpecTimerLines

	timerLinesSpec,
		err = TextLineSpecTimerLines{}.NewFullTimerEvent(
		leftMarginStr,
		startTimeLabel,
		startTime,
		endTimeLabel,
		endTime,
		timeFormat,
		timeDurationLabel,
		textLabelFieldLen,
		textLabelJustification,
		rightMarginStr,
		ePrefix.XCpy(
			"timerLinesSpec"))

	if err != nil {
		return strBuilder, err
	}

	return timerLinesSpec.TextBuilder(
		ePrefix.XCpy(
			"strBuilder<-timerLinesSpec"))

}
