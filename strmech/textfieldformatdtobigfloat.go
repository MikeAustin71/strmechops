package strmech

import (
	"fmt"
	ePref "github.com/MikeAustin71/errpref"
	"math/big"
	"strings"
	"sync"
)

// TextFieldFormatDtoBigFloat
//
// The TextFieldFormatDtoBigFloat type encapsulates input
// specifications for a text field populated with a
// big.Float floating point value formatted as a number
// string.
//
// Field Format Data Transfer Objects (Dto) are used
// to facilitate easy data entry which creating and
// configuring text lines strings for screen display,
// file output or printing.
//
// This type implements the ITextFieldFormatDto
// interface.
type TextFieldFormatDtoBigFloat struct {
	LeftMarginStr string
	//	One or more characters used to create a left
	//	margin for the 'BigFloatNum' Text Field.
	//
	//	If this parameter is set to an empty string, no
	//	left margin will be configured for this
	//	'BigFloatNum' Text Field.

	BigFloatNum big.Float
	// The big.Float floating point number to
	// be formatted for output as a text string.

	LeadingMinusSign bool
	// When generating rounded pure number strings,
	// setting this parameter to 'true' will ensure
	// that negative numeric values will be prefixed
	// with a leading minus sign ('-').
	//
	//		Example: -123.456
	//
	// Bear in mind that packages and parsing functions
	// provided by the Go Programming Language, as well
	// as many other programming languages, often require
	// that negative numeric values be formatted with
	// leading minus signs.
	//
	// If this parameter is set to false, negative
	// numeric values will be suffixed with a trailing
	// minus sign ('-'). Trailing minus signs are used
	// in Europe and many other countries across the
	// globe.
	//
	//		Example 123.456-
	//
	// Again this only applies to rounded pure number
	// strings. Native number strings generated by the
	// Golang 'strconv' package will always format
	// negative numbers with a leading minus sign.
	//
	//		Example: -123.456

	NativeRoundingMode big.RoundingMode
	// The native rounding mode used internally to round
	// 'BigFloatNum' values to a specific number of
	// fractional digits when performing internal
	// calculations.
	//
	// 'NativeRoundingMode' is NOT used when rounding
	// the big.Float numerical value for presentation in
	// number strings. Parameter 'RoundingType' is used
	// to perform rounding for number string
	// presentations.
	//
	// Rounding Modes are defined in Golang as follows:
	//
	//	ToNearestEven RoundingMode == IEEE 754-2008 roundTiesToEven
	//	ToNearestAway == IEEE 754-2008 roundTiesToAway
	//	ToZero        == IEEE 754-2008 roundTowardZero
	//	AwayFromZero  == no IEEE 754-2008 equivalent
	//	ToNegativeInf == IEEE 754-2008 roundTowardNegative
	//	ToPositiveInf == IEEE 754-2008 roundTowardPositive
	//
	//	If in doubt as this setting, 'big.AwayFromZero'
	//	is a common selection for rounding mode. The
	//	default applied by Golang is big.ToNearestEven
	//	simply because the Mode 'enumeration' integer
	//	value is zero.

	RoundingType NumberRoundingType
	//	This enumeration parameter is used to specify the
	//	type of rounding algorithm that will be applied
	// 	for the	rounding of fractional digits contained
	//	in the 'Float64Num' value when configuring that
	//	value in number strings.
	//
	//	If in doubt as to a suitable rounding method,
	//	'HalfAwayFromZero' is a common selection.
	//
	//	Possible values are listed as follows:
	//
	//		* INVALID VALUE *
	//		NumRoundType.None() - Invalid Value
	//
	//		* Valid Values *
	//		NumRoundType.NoRounding()
	//		NumRoundType.HalfUpWithNegNums()
	//		NumRoundType.HalfDownWithNegNums()
	//		NumRoundType.HalfAwayFromZero()
	//		NumRoundType.HalfTowardsZero()
	//		NumRoundType.HalfToEven()
	//		NumRoundType.HalfToOdd()
	//		NumRoundType.Randomly()
	//		NumRoundType.Floor()
	//		NumRoundType.Ceiling()
	//		NumRoundType.Truncate()
	//
	//	Definitions:
	//
	//		NoRounding
	//
	//			Signals that no rounding operation will be
	//			performed on fractional digits. The
	//			fractional digits will therefore remain
	//			unchanged.
	//
	//		HalfUpWithNegNums
	//
	//			Half Round Up Including Negative Numbers.
	//			This method is intuitive but may produce
	//			unexpected results when applied to negative
	//			numbers.
	//
	//			'HalfUpWithNegNums' rounds .5 up.
	//
	//				Examples of 'HalfUpWithNegNums'
	//				7.6 rounds up to 8
	//				7.5 rounds up to 8
	//				7.4 rounds down to 7
	//				-7.4 rounds up to -7
	//				-7.5 rounds up to -7
	//				-7.6 rounds down to -8
	//
	//		HalfDownWithNegNums
	//
	//		Half Round Down Including Negative Numbers. This
	//		method is also considered intuitive but may
	//		produce unexpected results when applied to
	//		negative numbers.
	//
	//		'HalfDownWithNegNums' rounds .5 down.
	//
	//			Examples of HalfDownWithNegNums
	//
	//			7.6 rounds up to 8
	//			7.5 rounds down to 7
	//			7.4 rounds down to 7
	//			-7.4 rounds up to -7
	//			-7.5 rounds down to -8
	//			-7.6 rounds down to -8
	//
	//		HalfAwayFromZero
	//
	//			The 'HalfAwayFromZero' method rounds .5 further
	//			away from zero.	It provides clear and consistent
	//			behavior when dealing with negative numbers.
	//
	//				Examples of HalfAwayFromZero
	//
	//				7.6 rounds away to 8
	//				7.5 rounds away to 8
	//				7.4 rounds to 7
	//				-7.4 rounds to -7
	//				-7.5 rounds away to -8
	//				-7.6 rounds away to -8
	//
	//		HalfTowardsZero
	//
	//			Round Half Towards Zero. 'HalfTowardsZero' rounds
	//			0.5	closer to zero. It provides clear and
	//			consistent behavior	when dealing with negative
	//			numbers.
	//
	//				Examples of HalfTowardsZero
	//
	//				7.6 rounds away to 8
	//				7.5 rounds to 7
	//				7.4 rounds to 7
	//				-7.4 rounds to -7
	//				-7.5 rounds to -7
	//				-7.6 rounds away to -8
	//
	//		HalfToEven
	//
	//			Round Half To Even Numbers. 'HalfToEven' is
	//			also called	Banker's Rounding. This method
	//			rounds 0.5 to the nearest even digit.
	//
	//				Examples of HalfToEven
	//
	//				7.5 rounds up to 8 (because 8 is an even
	//				number)	but 6.5 rounds down to 6 (because
	//				6 is an even number)
	//
	//				HalfToEven only applies to 0.5. Other
	//				numbers (not ending	in 0.5) round to
	//				nearest as usual, so:
	//
	//				7.6 rounds up to 8
	//				7.5 rounds up to 8 (because 8 is an even number)
	//				7.4 rounds down to 7
	//				6.6 rounds up to 7
	//				6.5 rounds down to 6 (because 6 is an even number)
	//				6.4 rounds down to 6
	//
	//		HalfToOdd
	//
	//			Round Half to Odd Numbers. Similar to 'HalfToEven',
	//			but in this case 'HalfToOdd' rounds 0.5 towards odd
	//			numbers.
	//
	//				Examples of HalfToOdd
	//
	//				HalfToOdd only applies to 0.5. Other numbers
	//				(not ending	in 0.5) round to nearest as usual.
	//
	//				7.5 rounds down to 7 (because 7 is an odd number)
	//
	//				6.5 rounds up to 7 (because 7 is an odd number)
	//
	//				7.6 rounds up to 8
	//				7.5 rounds down to 7 (because 7 is an odd number)
	//				7.4 rounds down to 7
	//				6.6 rounds up to 7
	//				6.5 rounds up to 7 (because 7 is an odd number)
	//				6.4 rounds down to 6
	//
	//		Randomly
	//
	//			Round Half Randomly. Uses a Random Number Generator
	//			to choose between rounding 0.5 up or down.
	//
	//			All numbers other than 0.5 round to the nearest as
	//			usual.
	//
	//		Floor
	//
	//			Yields the nearest integer down. Floor does not apply
	//			any	special treatment to 0.5.
	//
	//			Floor Function: The greatest integer that is less than
	//			or equal to x
	//
	//			Source:
	//				https://www.mathsisfun.com/sets/function-floor-ceiling.html
	//
	//			In mathematics and computer science, the floor function
	//			is the function that takes as input a real number x,
	//			and gives as output the greatest integer less than or
	//			equal to x,	denoted floor(x) or ⌊x⌋.
	//
	//			Source:
	//				https://en.wikipedia.org/wiki/Floor_and_ceiling_functions
	//
	//			Examples of Floor
	//
	//				Number     Floor
	//				 2           2
	//				 2.4         2
	//				 2.9         2
	//				-2.5        -3
	//				-2.7        -3
	//				-2          -2
	//
	//		Ceiling
	//
	//			Yields the nearest integer up. Ceiling does not
	//			apply any special treatment to 0.5.
	//
	//			Ceiling Function: The least integer that is
	//			greater than or	equal to x.
	//			Source:
	//				https://www.mathsisfun.com/sets/function-floor-ceiling.html
	//
	//			The ceiling function maps x to the least integer
	//			greater than or equal to x, denoted ceil(x) or
	//			⌈x⌉.[1]
	//
	//			Source:
	//				https://en.wikipedia.org/wiki/Floor_and_ceiling_functions
	//
	//				Examples of Ceiling
	//
	//					Number    Ceiling
	//					 2           2
	//					 2.4         3
	//					 2.9         3
	//					-2.5        -2
	//					-2.7        -2
	//					-2          -2
	//
	//		Truncate
	//
	//			Apply NO Rounding whatsoever. The Round From Digit
	//			is dropped or deleted. The Round To Digit is NEVER
	//			changed.
	//
	//			Examples of Truncate
	//
	//				Example-1
	//				Number: 23.14567
	//				Objective: Round to two decimal places to
	//				the right of the decimal point.
	//				Rounding Method: Truncate
	//				Round To Digit:   4
	//				Round From Digit: 5
	//				Rounded Number:   23.14 - The Round From Digit
	//				is dropped.
	//
	//				Example-2
	//				Number: -23.14567
	//				Objective: Round to two decimal places to
	//				the right of the decimal point.
	//				Rounding Method: Truncate
	//				Round To Digit:   4
	//				Round From Digit: 5
	//				Rounded Number:  -23.14 - The Round From Digit
	//				is dropped.

	NumOfFractionalDigits int
	// The number of digits to the right of the radix
	// point (a.k.a. decimal point) which will be
	// displayed in the formatted text string for the
	// big.Float floating point number, 'BigFloatNum'.
	//
	// If this value is set to minus one (-1), all
	// available fractional digits to the right of the
	// decimal point will be displayed

	DefaultNumStrFmt NumStrFormatSpec
	// The default Number String Format Specification
	// applied by this instance of
	// TextFieldFormatDtoBigFloat.
	//
	// The member variables contained in this structure
	// provide the detail specifications required to
	// support number string multinational and
	// multicultural formatting requirements.
	//
	// If this 'DefaultNumStrFmt' is invalid or
	// uninitialized, it will be set to the standard
	// US (United States) Signed Number String Format
	// Specification.
	//
	// Users can set the 'DefaultNumStrFmt' parameter
	// by calling method:
	//
	//	TextFieldFormatDtoBigFloat.SetDefaultNumStrFmt()
	//
	// The NumStrFormatSpec data structure is defined
	// as follows:
	//
	//		type NumStrFormatSpec struct {
	//
	//			decSeparator			DecimalSeparatorSpec
	//
	//				Contains the radix point or decimal
	//				separator character(s) which will
	//				separate integer and fractional
	//				numeric digits in a floating point
	//				number.
	//
	//			intSeparatorSpec 		IntegerSeparatorSpec
	//
	//				Integer Separator Specification. This
	//				parameter specifies the type of integer
	//				specifies the type of integer grouping and
	//				integer separator characters which will be
	//				applied to the number string formatting
	//				operations.
	//
	//			positiveNumberSign		NumStrNumberSymbolSpec
	//
	//				Positive number signs are commonly implied
	//				and not specified. However, the user as the
	//				option to specify a positive number sign
	//				character or characters for positive numeric
	//				values using a Number String Positive Number
	//				Sign Specification.
	//
	//				This specification can also be used to
	//				configure currency symbols.
	//
	//			negativeNumberSign		NumStrNumberSymbolSpec
	//
	//				The Number String Negative Number Sign
	//				Specification is used to configure negative
	//				number sign symbols for negative numeric values
	//				formatted and displayed in number stings.
	//
	//				This specification can also be used to
	//				configured currency symbols.
	//
	//			numberFieldSpec			NumStrNumberFieldSpec
	//
	//				This Number String Number Field Specification
	//				contains the field length and text
	//				justification parameter necessary to display
	//				a numeric value within a text number field
	//				for display as a number string.
	//		}

	FieldLength int
	//	The length of the text field in which the
	//	'BigFloatNum' string will be displayed. If
	//	'FieldLength' is less than the length of the
	//	'BigFloatNum' string, it will be automatically
	//	set equal to the 'BigFloatNum' string length.
	//
	//	To automatically set the value of 'FieldLength'
	//	to the length of the 'BigFloatNum' string, set
	//	this parameter to a value of minus one (-1).
	//
	//	If this parameter is submitted with a value less
	//	than minus one (-1) or greater than 1-million
	//	(1,000,000), an error will be returned.
	//
	//	Field Length Examples
	//
	//		Example-1
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = 25
	//			FieldJustify = TxtJustify.Center()
	//			Text Field String =
	//				"   5672.12345678901234   "
	//
	//		Example-2
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = 25
	//			FieldJustify = TxtJustify.Right()
	//			Text Field String =
	//				"      5672.12345678901234"
	//
	//		Example-3
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = -1
	//			FieldJustify = TxtJustify.Center() // Ignored
	//			Text Field String =
	//				"5672.12345678901234"

	FieldJustify TextJustify
	//	An enumeration which specifies the justification
	//	of the 'FieldDateTime' string within the text
	//	field length specified by 'FieldLength'.
	//
	//	Text justification can only be evaluated in the
	//	context of a text label ('FieldDateTime'), field
	//	length ('FieldLength') and a Text Justification
	//	object of type TextJustify. This is because text
	//	labels with a field length equal to or less than
	//	the length of the text label string will never
	//	use text justification. In these cases, text
	//	justification is completely ignored.
	//
	//	If the field length is greater than the length of
	//	the text label string, text justification must be
	//	equal to one of these three valid values:
	//
	//	    TextJustify(0).Left()
	//	    TextJustify(0).Right()
	//	    TextJustify(0).Center()
	//
	//	Users can also specify the abbreviated text
	//	justification enumeration syntax as follows:
	//
	//	    TxtJustify.Left()
	//	    TxtJustify.Right()
	//	    TxtJustify.Center()
	//
	//	Text Justification Examples
	//
	//		Example-1
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = 25
	//			FieldJustify = TxtJustify.Center()
	//			Text Field String =
	//				"   5672.12345678901234   "
	//
	//		Example-2
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = 25
	//			FieldJustify = TxtJustify.Right()
	//			Text Field String =
	//				"      5672.12345678901234"
	//
	//		Example-3
	//          BigFloatNum String = "5672.12345678901234"
	//			BigFloatNum String Length = 19
	//			FieldLength = -1
	//			FieldJustify = TxtJustify.Center() // Ignored
	//			Text Field String =
	//				"5672.12345678901234"

	RightMarginStr string
	//	One or more characters used to create a right
	//	margin for this 'FieldDateTime' Text Field.
	//
	//	If this parameter is set to an empty string, no
	//	right margin will be configured for this
	//	'FieldDateTime' Text Field.

	lock *sync.Mutex
}

// CopyIn
//
// Copies all the data fields from an incoming instance
// of TextFieldFormatDtoBigFloat
// ('incomingTxtBigFloatFmtDto') to the corresponding
// data fields of the current TextFieldFormatDtoBigFloat
// instance ('textBigFloatFieldFmtDto').
//
// ----------------------------------------------------------------
//
// # IMPORTANT
//
//	This method will delete and overwrite all
//	pre-existing data values contained within the
//	current instance of TextFieldFormatDtoBigFloat
//	('textBigFloatFieldFmtDto').
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	incomingTxtBigFloatFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		All the internal data field values in this
//		instance will be copied to corresponding data
//		fields of the current TextFieldFormatDtoBigFloat
//		instance.
//
//		The data fields contained in
//		'incomingTxtFieldFmtDto' will NOT be changed or
//		modified.
//
//		If 'incomingTxtBigFloatFmtDto' contains invalid
//		data values, an error will be returned.
//
//	errorPrefix						interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) CopyIn(
	incomingTxtBigFloatFmtDto *TextFieldFormatDtoBigFloat,
	errorPrefix interface{}) error {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"CopyIn()",
		"")

	if err != nil {
		return err
	}

	return new(textBigFloatFieldFormatDtoNanobot).copy(
		textBigFloatFieldFmtDto,
		incomingTxtBigFloatFmtDto,
		ePrefix.XCpy(
			"textBigFloatFieldFmtDto<-"+
				"incomingTxtBigFloatFmtDto"))
}

// CopyOut
//
// Returns a deep copy of the current
// TextFieldFormatDtoBigFloat instance.
//
// If the current TextFieldFormatDtoBigFloat instance
// contains invalid member variable data values, this
// method will return an error.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//	The original member variable data values encapsulated
//	within the current TextFieldFormatDtoBigFloat
//	instance will NOT BE changed or modified.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	TextFieldFormatDtoBigFloat
//
//		If this method completes successfully and no
//		errors are encountered, this parameter will
//		return a deep copy of the current
//		TextFieldFormatDtoBigFloat instance.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) CopyOut(
	errorPrefix interface{}) (
	TextFieldFormatDtoBigFloat,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	newTxtBigFloatFieldFmtDto :=
		TextFieldFormatDtoBigFloat{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"CopyOut()",
		"")

	if err != nil {
		return newTxtBigFloatFieldFmtDto, err
	}

	err = new(textBigFloatFieldFormatDtoNanobot).copy(
		&newTxtBigFloatFieldFmtDto,
		textBigFloatFieldFmtDto,
		ePrefix.XCpy(
			"newTxtBigFloatFieldFmtDto<-"+
				"textBigFloatFieldFmtDto"))

	return newTxtBigFloatFieldFmtDto, err
}

// CopyOutITextFieldFormat
//
// Returns a deep copy of the current
// TextFieldFormatDtoBigFloat instance cast as an
// ITextFieldFormatDto interface object.
//
// If the current TextFieldFormatDtoBigFloat instance
// contains invalid member variable data values, this
// method will return an error.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//	The original member variable data values encapsulated
//	within the current TextFieldFormatDtoBigFloat
//	instance will NOT BE changed or modified.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	ITextFieldFormatDto
//
//		If this method completes successfully and no
//		errors are encountered, this parameter will
//		return a deep copy of the current
//		TextFieldFormatDtoBigFloat instance cast as an
//		ITextFieldFormatDto interface object.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) CopyOutITextFieldFormat(
	errorPrefix interface{}) (
	ITextFieldFormatDto,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	newTxtBigFloatFieldFmtDto :=
		TextFieldFormatDtoBigFloat{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"CopyOut()",
		"")

	if err != nil {
		return ITextFieldFormatDto(&newTxtBigFloatFieldFmtDto),
			err
	}

	err = new(textBigFloatFieldFormatDtoNanobot).copy(
		&newTxtBigFloatFieldFmtDto,
		textBigFloatFieldFmtDto,
		ePrefix.XCpy(
			"newTxtBigFloatFieldFmtDto<-"+
				"textBigFloatFieldFmtDto"))

	return ITextFieldFormatDto(&newTxtBigFloatFieldFmtDto),
		err
}

// Empty
//
// Resets all internal member variables for the current
// instance of TextFieldFormatDtoBigFloat to their zero
// or uninitialized states. This method will leave the
// current instance of TextFieldFormatDtoBigFloat in an
// invalid state and unavailable for immediate reuse.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # IMPORTANT
//
// This method will delete all member variable data
// values in the current instance of
// TextFieldFormatDtoBigFloat. All member variable data
// values will be reset to their zero or uninitialized
// states.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	NONE
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	NONE
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) Empty() {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	new(textFieldFormatDtoBigFloatAtom).empty(
		textBigFloatFieldFmtDto)

	textBigFloatFieldFmtDto.lock.Unlock()

	textBigFloatFieldFmtDto.lock = nil

}

// Equal
//
// Receives a pointer to another instance of
// TextFieldFormatDtoBigFloat and proceeds to compare the
// member variables to those contained in the current
// TextFieldFormatDtoBigFloat instance in order to
// determine if they are equivalent.
//
// A boolean flag showing the result of this comparison
// is returned. If the member variables of both instances
// are equal in all respects, this flag is set to 'true'.
// Otherwise, this method returns 'false'.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	incomingTxtLabelFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an incoming instance of
//		TextFieldFormatDtoBigFloat. This method will
//		compare all member variable data values in this
//		instance against those contained in the current
//		instance of TextFieldFormatDtoBigFloat. If the
//		data values in both instances are found to be
//		equal in all respects, this method will return a
//		boolean value of 'true'.
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	bool
//
//		If the member variable data values contained in
//		input parameter 'incomingBigFloatFieldFmtDto' are
//		equal in all respects to those contained in the
//		current instance of TextFieldFormatDtoBigFloat,
//		this method will return a boolean value of
//		'true'. Otherwise, a value of 'false' will be
//		returned to the calling function.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) Equal(
	incomingBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) bool {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return new(textFieldFormatDtoBigFloatAtom).
		equal(
			textBigFloatFieldFmtDto,
			incomingBigFloatFieldFmtDto)
}

//	FmtNativeNumberStr
//
//	Extracts the specifications necessary to format and
//	return a floating point native number string from
//	the current instance of TextFieldFormatDtoBigFloat.
//
//	A native number string is generated using the
//	Text function from the Golang 'big' package or
//	library ('big.Float.Text()'). Formatting options are
//	therefore limited.
//
//	The floating point native number string returned
//	by this method will therefore:
//
//	 1.	Consist entirely of numeric digit characters with
//		the following exceptions.
//
//	 2.	Separate integer and fractional digits with a
//		decimal point ('.').
//
//	 3.	Designate negative values with a leading minus
//		sign ('-').
//
//	 4.	NOT include integer separators such as commas
//		(',') to separate integer digits by thousands.
//
//							NOT THIS: 1,000,000
//				Native Number String: 1000000
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//  1. Native number strings Do NOT include integer
//     separators (i.e. commas ',') to separate integer
//     number strings into thousands.
//
//     NOT THIS: 1,000,000
//     Native Number String: 1000000
//
//  2. Note that the placement of the leading minus sign
//     is fixed and completely controlled by the Golang
//     'big' package. Trailing minus signs are therefore
//     NOT supported. Only Leading minus signs will be
//     presented for negative numeric values.
//
//  3. The type of Rounding algorithm applied when
//     generating a native number string is controlled
//     by the Mode parameter contained in the current
//     instance of TextFieldFormatDtoBigFloat. The member variable
//     is named:
//
//     TextFieldFormatDtoBigFloat.NativeRoundingMode
//
//  4. The number of decimal digits to the right of the
//     decimal point returned in a native number string
//     is controlled by the 'TextFieldFormatDtoBigFloat'
//     parameter 'NumOfFractionalDigits'. If this
//     parameter is set to minus one (-1), all available
//     fractional digits in the big.Float numeric value
//     will be returned in the native number string.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, this
//		string parameter will return a floating point
//		native number string representation of the
//		big.Float value contained in the current instance
//		of TextFieldFormatDtoBigFloat.
//
//		The returned floating point native number string
//		will:
//
//		1.	Consist entirely of numeric digit characters
//			with the following exceptions.
//
//		2.	Separate integer and fractional digits with a
//			decimal point ('.').
//
//		3.	Designate negative values with a leading minus
//			sign ('-').
//
//		4.	NOT include integer separators such as commas
//			(',') to separate integer digits by thousands.
//
//							NOT THIS: 1,000,000
//				Native Number String: 1000000
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) FmtNativeNumberStr(
	errorPrefix interface{}) (
	string,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"FmtPureNumberStr()",
		"")

	if err != nil {
		return "", err
	}

	return new(textFieldFormatDtoBigFloatElectron).
		getBigFloatNativeNumStr(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))
}

//	FmtNumStr
//
//	Returns a formatted number string using the
//	numeric value provided by the current instance
//	of TextFieldFormatDtoBigFloat.
//
//	Input parameter 'numStrFmtSpec' provides options
//	for customizing number string currency symbols,
//	integer separation, number sign management and radix
//	point symbols.
//
//	If required, users also have the option of
//	implementing the India or Chinese Numbering Systems
//	for integer separation.
//
//	The numeric value used to generate the returned
//	NumberStrKernel will be taken from the
//	TextFieldFormatDtoBigFloat member variable,
//	'BigFloatNum'. This floating point numeric value will
//	be rounded according to the specifications contained
//	in member variables:
//
//		TextFieldFormatDtoBigFloat.RoundingType
//						AND
//		TextFieldFormatDtoBigFloat.NumOfFractionalDigits
//
//	If either of these rounding specifications are
//	invalid, an error will be returned.
//
//	The Number String Formatting Specifications supplied
//	by input parameter 'numStrFmtSpec' includes field
//	length and field justification specifications. These
//	values will override those configured in the current
//	instance of TextFieldFormatDtoBigFloat. This means that
//	the following member variables will be ignored:
//
//		TextFieldFormatDtoBigFloat.FieldLength
//						AND
//		TextFieldFormatDtoBigFloat.FieldJustify
//
//	Be sure to configure input parameter 'numStrFmtSpec'
//	accordingly.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	numStrFmtSpec				NumStrFormatSpec
//
//		This structure contains all the parameters
//		necessary for number string formatting. The
//		customization options contained in
//		'numStrFmtSpec' provide maximum granularity in
//		controlling the formatting of the returned Number
//		String.
//
//		The NumStrFormatSpec data structure is defined as
//		follows:
//
//		type NumStrFormatSpec struct {
//
//			decSeparator			DecimalSeparatorSpec
//
//				Contains the radix point or decimal
//				separator character(s) which will
//				separate integer and fractional
//				numeric digits in a floating point
//				number.
//
//			intSeparatorSpec 		IntegerSeparatorSpec
//
//				Integer Separator Specification. This
//				parameter specifies the type of integer
//				specifies the type of integer grouping and
//				integer separator characters which will be
//				applied to the number string formatting
//				operations.
//
//			positiveNumberSign		NumStrNumberSymbolSpec
//
//				Positive number signs are commonly implied
//				and not specified. However, the user as the
//				option to specify a positive number sign
//				character or characters for positive numeric
//				values using a Number String Positive Number
//				Sign Specification.
//
//				This specification can also be used to
//				configure currency symbols.
//
//			negativeNumberSign		NumStrNumberSymbolSpec
//
//				The Number String Negative Number Sign
//				Specification is used to configure negative
//				number sign symbols for negative numeric values
//				formatted and displayed in number stings.
//
//				This specification can also be used to
//				configured currency symbols.
//
//			numberFieldSpec			NumStrNumberFieldSpec
//
//				This Number String Number Field Specification
//				contains the field length and text
//				justification parameter necessary to display
//				a numeric value within a text number field
//				for display as a number string.
//		}
//
//	 errorPrefix                interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it	contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, a formatted
//		Number String will be returned.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) FmtNumStr(
	numStrFmtSpec NumStrFormatSpec,
	errorPrefix interface{}) (
	string,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"FmtNumStr()",
		"")

	if err != nil {
		return "", err
	}

	return new(textBigFloatFieldFormatDtoMolecule).
		fmtNumStrWithFormatSpec(
			textBigFloatFieldFmtDto,
			numStrFmtSpec,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto,"+
					" numStrFmtSpec"))
}

//	FmtPureNumberStr
//
//	Extracts the specifications necessary to format
//	and return a rounded floating point pure number
//	string from the current instance of
//	TextFieldFormatDtoBigFloat. The returned rounded
//	pure number string is generated from a conversion
//	algorithm provided by type 'NumberStrKernel'.
//
//	A rounded pure number string differs from a
//	'native' number string in that rounded pure number
//	string uses the following TextFieldFormatDtoBigFloat
//	member variables to generate a number string using
//	the conversion algorithms provided by type
//	'NumberStrKernel':
//
//		TextFieldFormatDtoBigFloat.LeadingMinusSign
//		TextFieldFormatDtoBigFloat.RoundingType
//		TextFieldFormatDtoBigFloat.NumOfFractionalDigits
//
//	Users will note that rounded pure number strings
//	offer more flexibility than native strings when
//	attempting to conform to multinational and
//	multicultural number string formatting conventions.
//
//	The rounded floating point pure number string returned
//	by this method will:
//
//	1.	Consist entirely of numeric digit characters
//		with the following exceptions.
//
//	2.	Separate integer and fractional digits with a
//	  	decimal point ('.').
//
//	3.	Designate negative values with a leading or
//		trailing minus sign ('-'). Minus sign
//		placement is controlled by member variable
//		TextFieldFormatDtoFloat64.LeadingMinusSign.
//
//			Leading Minus Sign:		-1000000
//					OR
//			Trailing Minus Sign:	1000000-
//
//	 4.	NOT include integer separators such as commas
//	    (',') to separate integer digits by thousands.
//
//	    			  NOT THIS: 1,000,000
//	    	Pure Number String: 1000000
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//  1. Pure number strings Do NOT include integer separators
//     (i.e. commas ',') to separate integer number strings
//     into thousands.
//
//     NOT THIS: 1,000,000
//     Pure Number String: 1000000
//
//  2. All negative numeric values processed by this method
//     will return number strings containing either a
//     leading minus sign ('-') or a trailing minus sign,
//     depending on the value of member variable:
//
//     TextFieldFormatDtoFloat64.LeadingMinusSign
//
//     Leading Minus Sign:	-1000000
//     OR
//     Trailing Minus Sign:	1000000-
//
//  3. Field Length and Field Justification are NOT used
//     when formatting rounded pure number strings.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, this
//		string parameter will return a pure number string
//		representation of the big.Float floating point
//		value specified by the current instance of
//		TextFieldFormatDtoBigFloat.
//
//		The returned floating point pure number string
//		will:
//
//		1.	Consist entirely of numeric digit characters.
//
//		2.	Separate integer and fractional digits with a
//			decimal point ('.').
//
//		3.	Designate negative values with a leading or
//			trailing minus sign ('-'). Minus sign
//			placement is controlled by member variable
//			TextFieldFormatDtoFloat64.LeadingMinusSign.
//
//				Leading Minus Sign:		-1000000
//						OR
//				Trailing Minus Sign:	1000000-
//
//		4.	NOT include integer separators such as commas
//			(',') to separate integer digits by thousands.
//
//						  NOT THIS: 1,000,000
//				Pure Number String: 1000000
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) FmtPureNumberStr(
	errorPrefix interface{}) (
	string,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"FmtPureNumberStr()",
		"")

	if err != nil {
		return "", err
	}

	return new(textFieldFormatDtoBigFloatElectron).
		getBigFloatRoundedPureNumStr(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))
}

// GetFieldContentTextLabel
//
// Converts the current TextFieldFormatDtoBigFloat
// instance member variable, 'BigFloatNum', to an
// instance of TextFieldSpecLabel.
//
// The returned TextFieldSpecLabel will only contain
// the member variable 'BigFloatNum'. It will NOT
// contain the left and right margins. In addition, the
// returned TextFieldSpecLabel will format the
// 'BigFloatNum' numeric value as a pure number string
// generated from a native number to string conversion.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
// The returned TextFieldSpecLabel will only contain
// the member variable 'BigFloatNum'. It will NOT
// contain the left and right margins.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it	contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	TextFieldSpecLabel
//
//		If this method completes successfully, the Text
//		Field Contents extracted from the current
//		instance of TextFieldFormatDtoBigFloat, will be
//		returned as text label of type
//		TextFieldSpecLabel.
//
//		This returned text label will ONLY contain the
//		Text Field Contents numeric value
//		('BigFloatNum'). It will NOT contain the left and
//		right margin strings.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetFieldContentTextLabel(
	errorPrefix interface{}) (
	TextFieldSpecLabel,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"GetFieldContentTextLabel()",
		"")

	if err != nil {
		return TextFieldSpecLabel{}, err
	}

	return new(textBigFloatFieldFormatDtoMolecule).
		getFieldContentTextLabel(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))
}

// GetFieldFormatDtoType
//
// Returns a string containing the name of this type
// ('TextFieldFormatDtoBigFloat').
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetFieldFormatDtoType() string {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return "TextFieldFormatDtoBigFloat"
}

// GetFormattedTextFieldStr
//
// Returns a string containing the formatted text field
// generated from the current instance of
// TextFieldFormatDtoBigFloat.
//
// The returned formatted text field string contains the
// left margin, field contents and right margin.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it	contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, the text
//		field specifications contained in the current
//		instance of TextFieldFormatDtoBigFloat will be
//		converted to, and returned as, a formatted text
//		field string.
//
//		The returned text field string will contain the
//		left margin, text field contents and right margin
//		as those elements are defined in the current
//		instance of TextFieldFormatDtoBigFloat.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetFormattedTextFieldStr(
	errorPrefix interface{}) (
	string,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"GetFormattedTextFieldStr()",
		"")

	if err != nil {
		return "", err
	}

	return new(textBigFloatFieldFormatDtoNanobot).
		getFormattedTextFieldStr(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))
}

// GetLeftMarginLength
//
// Returns the length of the Left Margin String as an
// integer value.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetLeftMarginLength() int {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return len(textBigFloatFieldFmtDto.LeftMarginStr)
}

// GetLeftMarginStr
//
// Returns the Left Margin String.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetLeftMarginStr() string {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return textBigFloatFieldFmtDto.LeftMarginStr
}

//	GetNumberStats
//
//	Returns an instance of NumberStrStatsDto profiling
//	the pure rounded number string generated by the
//	big.Float value encapsulated by the current instance
//	of TextFieldFormatDtoBigFloat.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	NumberStrStatsDto
//
//		This data transfer object will return critical
//		statistics and profiling on the numeric value
//		represented	by the big.Float value encapsulated
//		by the current instance of
//		TextFieldFormatDtoBigFloat.
//
//		Remember that these statistics and profiling data
//		describe the rounded pure number string generated
//		from the big.Float numeric value encapsulated by
//		the current instance of
//		TextFieldFormatDtoBigFloat.
//
//		The NumberStrStatsDto data structure is defined
//		as follows:
//
//		type NumberStrStatsDto struct {
//
//		NumOfIntegerDigits					uint64
//
//			The total number of integer digits to the
//			left of the radix point or, decimal point, in
//			the subject numeric value.
//
//		NumOfSignificantIntegerDigits		uint64
//
//			The number of nonzero integer digits to the
//			left of the radix point or, decimal point, in
//			the subject numeric value.
//
//		NumOfFractionalDigits				uint64
//
//			The total number of fractional digits to the
//			right of the radix point or, decimal point,
//			in the subject numeric value.
//
//		NumOfSignificantFractionalDigits	uint64
//
//			The number of nonzero fractional digits to
//			the right of the radix point or, decimal
//			point, in the subject numeric value.
//
//		NumberValueType 					NumericValueType
//
//			This enumeration value specifies whether the
//			subject numeric value is classified either as
//			an integer or a floating point number.
//
//			Possible enumeration values are listed as
//			follows:
//				NumValType.None()
//				NumValType.FloatingPoint()
//				NumValType.Integer()
//
//		NumberSign							NumericSignValueType
//
//			An enumeration specifying the number sign
//			associated with the numeric value. Possible
//			values are listed as follows:
//				NumSignVal.None()		= Invalid Value
//				NumSignVal.Negative()	= -1
//				NumSignVal.Zero()		=  0
//				NumSignVal.Positive()	=  1
//
//		IsZeroValue							bool
//
//			If 'true', the subject numeric value is equal
//			to zero ('0').
//
//			If 'false', the subject numeric value is
//			greater than or less than zero ('0').
//		}
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetNumberStats(
	errorPrefix interface{}) (
	NumberStrStatsDto,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	var numStatsDto NumberStrStatsDto

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"GetNumberStats()",
		"")

	if err != nil {
		return numStatsDto, err
	}

	var err2 error

	_,
		err2 = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))

	if err2 != nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: The current instance of TextFieldFormatDtoBigFloat\n"+
			"is improperly configured and Invalid!\n"+
			"Error=\n%v\n",
			ePrefix.String(),
			err2.Error())

		return numStatsDto, err
	}

	var numStrKernel NumberStrKernel

	numStrKernel,
		err = new(textFieldFormatDtoBigFloatElectron).
		getNumberStrKernel(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))

	if err != nil {
		return numStatsDto, err
	}

	numStatsDto,
		err = numStrKernel.GetNumericValueStats(
		ePrefix.XCpy(
			"numStrKernel<-" +
				"textBigFloatFieldFmtDto"))

	return numStatsDto, err
}

// GetNumberStrKernel
//
// Returns an instance of NumberStrKernel configured with
// the big.Float numeric value contained in the current
// instance of TextFieldFormatDtoBigFloat.
//
//	Type NumberStrKernel contains all the specifications
//	necessary to construct an integer or floating point
//	number string.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	NumberStrKernel
//
//		If this method completes successfully, a fully
//		populated instance of NumberStrKernel will be
//		returned. This instance will encapsulate number
//		string specifications configured for the
//		big.Float numeric value contained in the current
//		instance of TextFieldFormatDtoBigFloat.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetNumberStrKernel(
	errorPrefix interface{}) (
	NumberStrKernel,
	error) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"GetNumberStrKernel()",
		"")

	if err != nil {
		return NumberStrKernel{}, err
	}

	var err2 error

	_,
		err2 = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))

	if err2 != nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: The current instance of TextFieldFormatDtoBigFloat\n"+
			"is improperly configured and Invalid!\n"+
			"Error=\n%v\n",
			ePrefix.String(),
			err2.Error())

		return NumberStrKernel{}, err
	}

	return new(textFieldFormatDtoBigFloatElectron).
		getNumberStrKernel(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))
}

// GetRightMarginLength
//
// Returns the length of the Right Margin String as an
// integer value.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetRightMarginLength() int {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return len(textBigFloatFieldFmtDto.RightMarginStr)
}

// GetRightMarginStr
//
// Returns the Right Margin String.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) GetRightMarginStr() string {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	return textBigFloatFieldFmtDto.RightMarginStr
}

// IsValidInstance
//
// Performs a diagnostic review of the data values
// encapsulated in the current TextFieldFormatDtoBigFloat
// instance to determine if they are valid.
//
// If all data elements evaluate as valid, this method
// returns 'true'. If any data element is invalid, this
// method returns 'false'.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
// If TextFieldFormatDtoBigFloat.DefaultNumStrFmt is
// invalid, it will be reset to the standard US
// (United States) Signed Number String Formatting
// Specification.
//
// All other data values in the current instance of
// TextFieldFormatDtoBigFloat will remain unchanged.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	--- NONE ---
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	isValid						bool
//
//		If all data elements encapsulated by the current
//		instance of TextFieldFormatDtoBigFloat are valid,
//		this returned boolean value is set to 'true'. If
//		any data values are invalid, this return
//		parameter is set to 'false'.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) IsValidInstance() (
	isValid bool) {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	isValid,
		_ = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			textBigFloatFieldFmtDto,
			nil)

	return isValid
}

// IsValidInstanceError
//
// Performs a diagnostic review of the data values
// encapsulated in the current TextFieldFormatDtoBigFloat
// instance to determine if they are valid.
//
// If any data element evaluates as invalid, this method
// will return an error.
//
// This method is required in order to implement the
// ITextFieldFormatDto interface.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
// If TextFieldFormatDtoBigFloat.DefaultNumStrFmt is
// invalid, it will be reset to the standard US
// (United States) Signed Number String Formatting
// Specification.
//
// All other data values in the current instance of
// TextFieldFormatDtoBigFloat will remain unchanged.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it	contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If any of the internal member data variables
//		contained in the current instance of
//		TextFieldFormatDtoBigFloat are found to be
//		invalid, this method will return an error
//		containing an appropriate error message.
//
//		If an error message is returned, the returned
//		error message will incorporate the method chain
//		and text passed by input parameter, 'errorPrefix'.
//		The 'errorPrefix' text will be attached to the
//		beginning of the error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) IsValidInstanceError(
	errorPrefix interface{}) error {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"CopyIn()",
		"")

	if err != nil {
		return err
	}

	_,
		err = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))

	return err
}

//	SetDefaultNumStrFmt
//
//	Receives an instance of NumStrFormatSpec and proceeds
//	to copy that Number String Format Specification to
//	the internal default Number String Format
//	Specification contained in the current instance of
//	TextFieldFormatDtoBigFloat.
//
//		TextFieldFormatDtoBigFloat.DefaultNumStrFmt
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	numStrFmtSpec				NumStrFormatSpec
//
//		An instance of Number String Format Specification
//		('NumStrFormatSpec').
//
//		A deep copy of this instance will be copied to,
//		and stored in, the default Number String Format
//		Specification maintained by the current instance
//		of TextFieldFormatDtoBigFloat:
//
//			TextFieldFormatDtoBigFloat.DefaultNumStrFmt
//
//		Input parameter 'numStrFmtSpec' provides options
//		for customizing number string currency symbols,
//		integer separation, number sign management and
//		radix point symbols.
//
//		The 'numStrFmtSpec' format specification will be
//		used to format the TextFieldFormatDtoBigFloat
//		big.Float value in a number string for screen
//		displays, file output and printing.
//
//		If 'numStrFmtSpec' is found to be invalid, an
//		error will be returned.
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) SetDefaultNumStrFmt(
	numStrFmtSpec NumStrFormatSpec,
	errorPrefix interface{}) error {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"SetDefaultNumStrFmt()",
		"")

	if err != nil {
		return err
	}

	var err2 error

	_,
		err2 = new(numStrFmtSpecAtom).
		testValidityNumStrFormatSpec(
			&numStrFmtSpec,
			ePrefix.XCpy(
				"numStrFmtSpec"))

	if err2 != nil {
		err = fmt.Errorf("%v\n"+
			"Error: Input parameter 'numStrFmtSpec' is invalid!\n"+
			"Error = \n%v\n",
			ePrefix.String(),
			err2.Error())

		return err
	}

	err = textBigFloatFieldFmtDto.
		DefaultNumStrFmt.CopyIn(
		&numStrFmtSpec,
		ePrefix.XCpy(
			"textBigFloatFieldFmtDto.DefaultNumStrFmt<-"+
				"numStrFmtSpec"))

	return err
}

//	SetPureNumStr
//
//	Receives and converts pure number string to a
//	big.Float floating point numeric value which is then
//	assigned to the big.Flat value encapsulated in the
//	current instance of TextFieldFormatDtoFloat64.
//
//	The parsed big.Float value extracted from the pure
//	number string will be stored in the member variable:
//
//		TextFieldFormatDtoBigFloat.BigFloatNum
//
//
//	The input parameter 'pureNumStr' must be formatted as
//	a pure number string in accordance with the following
//	criteria:
//
//		1.	The pure number string must consist entirely
//			of numeric digit characters (0-9), with the
//			following exceptions.
//
//		2.	For floating point values, the pure number
//			string must separate integer and fractional
//			digits with a decimal point ('.').
//
//		3.	The pure number string must designate
//			negative values with a leading minus sign
//			('-'). Trailing minus signs are NOT
//			supported.
//
//		4.	The pure number string must NOT include integer
//			separators such as commas (',') to separate
//			integer digits by thousands.
//
//						  NOT THIS: 1,000,000
//				Pure Number String: 1000000
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	pureNumStr					string
//
//		This string contains the pure number string which
//		will be parsed to produce and store a big.Float
//		numeric value in the current instance of
//		TextFieldFormatDtoBigFloat.
//
//		The parsed big.Float value will be stored in the
//		member variable:
//
//			TextFieldFormatDtoBigFloat.BigFloatNum
//
//		The input parameter 'pureNumStr' must be formatted
//		as a pure number in accordance with the following
//		criteria:
//
//			1.	The pure number string must consist entirely
//				of numeric digit characters (0-9), with
//				following exceptions.
//
//			2.	For floating point values, the pure number
//				string must separate integer and fractional
//				digits with a decimal point ('.').
//
//			3.	The pure number string must designate
//				negative values with a leading minus sign
//				('-'). Trailing minus signs are NOT
//				supported.
//
//			4.	The pure number string must NOT include integer
//				separators such as commas (',') to separate
//				integer digits by thousands.
//
//							  NOT THIS: 1,000,000
//					Pure Number String: 1000000
//
//		If the input parameter 'pureNumStr' does NOT meet these
//		criteria, an error will be returned.
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set this
//		parameter to 'nil'.
//
//		This empty interface must be convertible to one of
//		the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (textBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) SetPureNumStr(
	pureNumStr string,
	errorPrefix interface{}) error {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"TextFieldFormatDtoBigFloat."+
			"SetPureNumStr()",
		"")

	if err != nil {
		return err
	}

	var bFloat big.Float

	bFloat,
		err = new(MathFloatHelper).PureNumStrToBigFloat(
		pureNumStr,
		textBigFloatFieldFmtDto.NativeRoundingMode,
		ePrefix.XCpy(
			"bFloat<-pureNumStr"))

	if err != nil {
		return err
	}

	textBigFloatFieldFmtDto.BigFloatNum.Copy(
		&bFloat)

	return err
}

//	String
//
//	Returns a number string comprised of the big.Float
//	floating point numeric value contained in the current
//	instance of TextFieldFormatDtoBigFloat.
//
//	The returned number string will be formatted using
//	the default Number String Formatting Specification
//	contained in the current instance of
//	TextFieldFormatDtoBigFloat.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	NONE
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, a
//		formatted Number String will be returned. If
//		errors are encountered, this string will contain
//		an appropriate error message.
func (textBigFloatFieldFmtDto TextFieldFormatDtoBigFloat) String() string {

	if textBigFloatFieldFmtDto.lock == nil {
		textBigFloatFieldFmtDto.lock = new(sync.Mutex)
	}

	textBigFloatFieldFmtDto.lock.Lock()

	defer textBigFloatFieldFmtDto.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error
	var errOut string

	funcName := "TextFieldFormatDtoBigFloat.String()"

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		nil,
		funcName,
		"")

	if err != nil {
		errOut = fmt.Sprintf("%v\n"+
			"Error Message:\n"+
			"%v",
			funcName,
			err.Error())

		return errOut
	}

	var numStr string

	numStr,
		err = new(textBigFloatFieldFormatDtoNanobot).
		fmtDefaultNumStr(
			&textBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"textBigFloatFieldFmtDto"))

	if err != nil {

		errOut = fmt.Sprintf("%v\n"+
			"Error Message:\n"+
			"%v",
			funcName,
			err.Error())

		return errOut
	}

	return numStr
}

// textBigFloatFieldFormatDtoNanobot
//
// Provides helper methods for TextFieldFormatDtoBigFloat.
type textBigFloatFieldFormatDtoNanobot struct {
	lock *sync.Mutex
}

// copy
//
// Copies all data from a source instance of
// TextFieldFormatDtoBigFloat to a destination instance of
// TextFieldFormatDtoBigFloat.
//
// ----------------------------------------------------------------
//
// # IMPORTANT
//
//	This method will delete and overwrite all
//	pre-existing data values contained within the
//	TextFieldFormatDtoBigFloat instance passed as input
//	parameter 'destinationTxtBigFloatFieldFmtDto'.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	destinationTxtBigFloatFmtDto	*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of TextFieldFormatDtoBigFloat.
//
//		Data extracted from input parameter
//		'sourceTxtBigFloatFmtDto' will be copied to this
//		input parameter, 'destinationTxtBigFloatFmtDto'.
//
//		'destinationTxtFieldFmtDto' is the destination
//		for this copy operation.
//
//		If this method completes successfully, all member
//		data variables encapsulated in
//		'destinationTxtBigFloatFmtDto' will be identical to
//		those contained in input parameter,
//		'sourceTxtBigFloatFmtDto'.
//
//		Be advised that the pre-existing data fields
//		contained within input parameter
//		'destinationTxtFieldFmtDto' will be overwritten
//		and deleted.
//
//	sourceTxtBigFloatFmtDto			*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		All data values in this TextFieldFormatDtoBigFloat
//		instance will be copied to input parameter
//		'destinationTxtBigFloatFmtDto'.
//
//		'sourceTxtBigFloatFmtDto' is the source of
//		the copy operation.
//
//		If 'sourceTxtBigFloatFmtDto' contains
//		invalid member data variables, an error will be
//		returned.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (txtBigFloatFieldFmtDtoNanobot *textBigFloatFieldFormatDtoNanobot) copy(
	destinationTxtBigFloatFmtDto *TextFieldFormatDtoBigFloat,
	sourceTxtBigFloatFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) error {

	if txtBigFloatFieldFmtDtoNanobot.lock == nil {
		txtBigFloatFieldFmtDtoNanobot.lock = new(sync.Mutex)
	}

	txtBigFloatFieldFmtDtoNanobot.lock.Lock()

	defer txtBigFloatFieldFmtDtoNanobot.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textBigFloatFieldFormatDtoNanobot."+
			"copy()",
		"")

	if err != nil {

		return err
	}

	if destinationTxtBigFloatFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'destinationTxtBigFloatFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return err
	}

	if sourceTxtBigFloatFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'sourceTxtBigFloatFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return err
	}

	txtBigFloatFieldFmtAtom := textFieldFormatDtoBigFloatAtom{}

	_,
		err = txtBigFloatFieldFmtAtom.
		testValidityOfTxtFieldFmtDtoBigFloat(
			sourceTxtBigFloatFmtDto,
			ePrefix.XCpy(
				"sourceTxtBigFloatFmtDto"))

	if err != nil {

		return err
	}

	txtBigFloatFieldFmtAtom.empty(
		destinationTxtBigFloatFmtDto)

	destinationTxtBigFloatFmtDto.LeftMarginStr =
		sourceTxtBigFloatFmtDto.LeftMarginStr

	destinationTxtBigFloatFmtDto.BigFloatNum.
		Copy(&sourceTxtBigFloatFmtDto.BigFloatNum)

	destinationTxtBigFloatFmtDto.LeadingMinusSign =
		sourceTxtBigFloatFmtDto.LeadingMinusSign

	destinationTxtBigFloatFmtDto.NativeRoundingMode =
		sourceTxtBigFloatFmtDto.NativeRoundingMode

	destinationTxtBigFloatFmtDto.RoundingType =
		sourceTxtBigFloatFmtDto.RoundingType

	destinationTxtBigFloatFmtDto.NumOfFractionalDigits =
		sourceTxtBigFloatFmtDto.NumOfFractionalDigits

	err = destinationTxtBigFloatFmtDto.
		DefaultNumStrFmt.CopyIn(
		&sourceTxtBigFloatFmtDto.DefaultNumStrFmt,
		ePrefix.XCpy(
			"destinationTxtBigFloatFmtDto<-"+
				"sourceTxtBigFloatFmtDto.DefaultNumStrFmt"))

	if err != nil {

		return err
	}

	destinationTxtBigFloatFmtDto.FieldLength =
		sourceTxtBigFloatFmtDto.FieldLength

	destinationTxtBigFloatFmtDto.FieldJustify =
		sourceTxtBigFloatFmtDto.FieldJustify

	destinationTxtBigFloatFmtDto.RightMarginStr =
		sourceTxtBigFloatFmtDto.RightMarginStr

	return err
}

// fmtDefaultNumStr
//
//	Receives a pointer to an instance of
//	TextFieldFormatDtoBigFloat
//	('txtBigFloatFieldFmtDto').
//
//	Using the default Number String Formatting
//	Specification contained in this instance, this method
//	will configure and return a fully formatted number
//	string.
//
//	If the default Number String Formatting Specification
//	contained in input parameter 'txtBigFloatFieldFmtDto'
//	is invalid, it will be defaulted and automatically
//	reset to the US (United States) Signed Number String
//	Formatting Specification.
//
//	Note that Field Length and Field Justification
//	specifications will be taken from the internal
//	'txtBigFloatFieldFmtDto' member variables:
//
//		txtBigFloatFieldFmtDto.FieldLength
//		txtBigFloatFieldFmtDto.FieldJustify
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The numeric value extracted from the instance
//		member variable 'BigFloatNum' will supply the
//		floating point value included in the returned
//		number string.
//
//		The instance member variable 'DefaultNumStrFmt'
//		will be used to generate the formatted number
//		string. If 'DefaultNumStrFmt' is invalid it will
//		be defaulted and automatically reset to the US
//		(United States) Signed Number String Formatting
//		Specification.
//
//		None of the other data values in this instance
//		will be changed or modified.
//
//		If this instance of TextFieldFormatDtoBigFloat
//		contains invalid data elements, an error will be
//		returned.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, a
//		formatted Number String will be returned.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtBigFloatFieldFmtDtoNanobot *textBigFloatFieldFormatDtoNanobot) fmtDefaultNumStr(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	string,
	error) {

	if txtBigFloatFieldFmtDtoNanobot.lock == nil {
		txtBigFloatFieldFmtDtoNanobot.lock = new(sync.Mutex)
	}

	txtBigFloatFieldFmtDtoNanobot.lock.Lock()

	defer txtBigFloatFieldFmtDtoNanobot.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	var numStr string

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textBigFloatFieldFormatDtoNanobot."+
			"fmtDefaultNumStr()",
		"")

	if err != nil {

		return numStr, err
	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return numStr, err
	}

	_,
		err = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return "", err

	}

	var numStrFmtSpec NumStrFormatSpec

	numStrFmtSpec,
		err = txtBigFloatFieldFmtDto.DefaultNumStrFmt.
		CopyOut(
			ePrefix.XCpy(
				"numStrFmtSpec<-" +
					"txtBigFloatFieldFmtDto.DefaultNumStrFmt"))

	if err != nil {

		return "", err

	}

	return new(textBigFloatFieldFormatDtoMolecule).
		fmtNumStrWithFormatSpec(
			txtBigFloatFieldFmtDto,
			numStrFmtSpec,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto.DefaultNumStrFmt"))
}

// getFormattedTextFieldStr
//
// Converts an instance of TextFieldFormatDtoBigFloat to a
// formatted text field string.
//
// This formatted text field string contains the left
// margin, field contents and right margin.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The left and right margins as well as the member
//		variable 'BigFloatNum' will be processed and
//		converted to a formatted text field for use in
//		screen displays, file output and printing.
//
//		If input parameter 'txtBigFloatFieldFmtDto' is
//		found to contain invalid data values, an error
//		will be returned.
//
//		None of the data values in this instance will be
//		changed or modified.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, the input
//		parameter, 'txtBigFloatFieldFmtDto', will be
//		converted to, and returned as, a formatted string
//		of text.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtBigFloatFieldFmtDtoNanobot *textBigFloatFieldFormatDtoNanobot) getFormattedTextFieldStr(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	string,
	error) {

	if txtBigFloatFieldFmtDtoNanobot.lock == nil {
		txtBigFloatFieldFmtDtoNanobot.lock = new(sync.Mutex)
	}

	txtBigFloatFieldFmtDtoNanobot.lock.Lock()

	defer txtBigFloatFieldFmtDtoNanobot.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textBigFloatFieldFormatDtoNanobot."+
			"getFormattedTextFieldStr()",
		"")

	if err != nil {

		return "", err
	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtLabelFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return "", err
	}

	strBuilder := new(strings.Builder)

	if len(txtBigFloatFieldFmtDto.LeftMarginStr) > 0 {

		strBuilder.WriteString(txtBigFloatFieldFmtDto.LeftMarginStr)

	}

	var textLabel TextFieldSpecLabel

	textLabel,
		err = new(textBigFloatFieldFormatDtoMolecule).
		getFieldContentTextLabel(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return "", err
	}

	strBuilder.WriteString(textLabel.GetTextLabel())

	if len(txtBigFloatFieldFmtDto.RightMarginStr) > 0 {

		strBuilder.WriteString(txtBigFloatFieldFmtDto.RightMarginStr)

	}

	return strBuilder.String(), err
}

// textBigFloatFieldFormatDtoMolecule - Provides helper methods for
// TextFieldFormatDtoBigFloat.
type textBigFloatFieldFormatDtoMolecule struct {
	lock *sync.Mutex
}

// getFieldContentTextLabel
//
// Converts a TextFieldFormatDtoBigFloat instance member
// variable, 'BigFloatNum', to an instance of
// TextFieldSpecLabel.
//
// The TextFieldFormatDtoBigFloat instance is passed as
// input parameter, 'txtBigFloatFieldFmtDto'.
//
// The returned TextFieldSpecLabel will only contain
// the member variable 'BigFloatNum'. It will NOT
// contain the left and right margins. The returned
// TextFieldSpecLabel will format the 'BigFloatNum'
// numeric value as a pure number string generated
// from a native number to string conversion.
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//	If input parameter 'txtBigFloatFieldFmtDto', an
//	instance of TextFieldFormatDtoBigFloat, is found to
//	be invalid, an error will be returned.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of TextFieldFormatDtoBigFloat.
//
//		The member variable 'BigFloatNum' will be
//		converted to a text label of type
//		TextFieldSpecLabel and returned to the calling
//		function.
//
//		None of the data values in this instance will be
//		changed or modified.
//
//		If this instance of TextFieldFormatDtoBigFloat
//		contains invalid data elements, an error will be
//		returned.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	TextFieldSpecLabel
//
//		If this method completes successfully, the Text
//		Field Contents extracted from the input
//		parameter, 'txtBigFloatFieldFmtDto', will be
//		returned as an instance of TextFieldSpecLabel.
//
//		This returned text label will ONLY contain the
//		Big Float numeric value ('BigFloatNum'). It will
//		NOT contain the left or right margin strings.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtBigFloatFieldFmtDtoMolecule *textBigFloatFieldFormatDtoMolecule) getFieldContentTextLabel(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	TextFieldSpecLabel,
	error) {

	if txtBigFloatFieldFmtDtoMolecule.lock == nil {
		txtBigFloatFieldFmtDtoMolecule.lock = new(sync.Mutex)
	}

	txtBigFloatFieldFmtDtoMolecule.lock.Lock()

	defer txtBigFloatFieldFmtDtoMolecule.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	fieldContentsLabel := TextFieldSpecLabel{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textBigFloatFieldFormatDtoMolecule."+
			"getFieldContentTextLabel()",
		"")

	if err != nil {

		return fieldContentsLabel, err
	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return fieldContentsLabel, err
	}

	var pureNumStr string

	pureNumStr,
		err = new(textFieldFormatDtoBigFloatElectron).
		getBigFloatNativeNumStr(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return fieldContentsLabel, err
	}

	fieldContentsLabel,
		err = TextFieldSpecLabel{}.NewTextLabel(
		pureNumStr,
		txtBigFloatFieldFmtDto.FieldLength,
		txtBigFloatFieldFmtDto.FieldJustify,
		ePrefix.XCpy(
			"fieldContentsLabel<-txtBigFloatFieldFmtDto"))

	return fieldContentsLabel, err
}

// fmtNumStrWithFormatSpec
//
//	Receives a pointer to an instance of
//	TextFieldFormatDtoBigFloat.
//
//	The numeric value contained in this instance is
//	converted to a number string using the specifications
//	contained in input parameter 'numStrFmtSpec', an
//	instance  of 'NumStrFormatSpec'.
//
//	Input parameter 'numStrFmtSpec' provides options
//	for customizing for currency symbols, integer
//	separation, number sign management, radix point
//	symbol.
//
//	If required, users also have the option of
//	implementing the India or Chinese Numbering Systems
//	for integer separation.
//
//	The numeric value used to generate the returned
//	NumberStrKernel will be taken from the
//	TextFieldFormatDtoBigFloat member variable,
//	'BigFloatNum'. This floating point numeric value will
//	be rounded according to the specifications contained
//	in member variables:
//
//		TextFieldFormatDtoBigFloat.RoundingType
//						AND
//		TextFieldFormatDtoBigFloat.NumOfFractionalDigits
//
//	If either of these rounding specifications are
//	invalid, an error will be returned.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The floating point numeric value contained in
//		this instance will be converted to a number
//		string using the Number String Formatting
//		Specifications supplied by input paramter
//		'numStrFmtSpec'.
//
//	numStrFmtSpec				NumStrFormatSpec
//
//		This structure includes all parameters
//		necessary for formatting a number string.
//		These customization options provide maximum
//		granularity in controlling the formatting
//		of the returned Number String.
//
//		type NumStrFormatSpec struct {
//
//			decSeparator			DecimalSeparatorSpec
//
//				Contains the radix point or decimal
//				separator character(s) which will
//				separate integer and fractional
//				numeric digits in a floating point
//				number.
//
//			intSeparatorSpec 		IntegerSeparatorSpec
//
//				Integer Separator Specification. This
//				parameter specifies the type of integer
//				specifies the type of integer grouping and
//				integer separator characters which will be
//				applied to the number string formatting
//				operations.
//
//			positiveNumberSign		NumStrNumberSymbolSpec
//
//				Positive number signs are commonly implied
//				and not specified. However, the user as the
//				option to specify a positive number sign
//				character or characters for positive numeric
//				values using a Number String Positive Number
//				Sign Specification.
//
//				This specification can also be used to
//				configure currency symbols.
//
//			negativeNumberSign		NumStrNumberSymbolSpec
//
//				The Number String Negative Number Sign
//				Specification is used to configure negative
//				number sign symbols for negative numeric values
//				formatted and displayed in number stings.
//
//				This specification can also be used to
//				configured currency symbols.
//
//			numberFieldSpec			NumStrNumberFieldSpec
//
//				This Number String Number Field Specification
//				contains the field length and text
//				justification parameter necessary to display
//				a numeric value within a text number field
//				for display as a number string.
//		}
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a function chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, a formatted
//		Number String will be returned.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message. This returned error message will
//		incorporate the method chain and text passed by
//		input parameter, 'errorPrefix'. The 'errorPrefix'
//		text will be attached to the beginning of the
//		error message.
func (txtBigFloatFieldFmtDtoMolecule *textBigFloatFieldFormatDtoMolecule) fmtNumStrWithFormatSpec(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	numStrFmtSpec NumStrFormatSpec,
	errPrefDto *ePref.ErrPrefixDto) (
	string,
	error) {

	if txtBigFloatFieldFmtDtoMolecule.lock == nil {
		txtBigFloatFieldFmtDtoMolecule.lock = new(sync.Mutex)
	}

	txtBigFloatFieldFmtDtoMolecule.lock.Lock()

	defer txtBigFloatFieldFmtDtoMolecule.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	numStr := ""

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textBigFloatFieldFormatDtoMolecule."+
			"fmtNumStrWithFormatSpec()",
		"")

	if err != nil {

		return numStr, err
	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return "", err
	}

	err = numStrFmtSpec.IsValidInstanceError(
		ePrefix.XCpy(
			"Input parameter numStrFmtSpec is invalid."))

	if err != nil {

		return numStr, err

	}

	var err2 error

	_,
		err2 = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err2 != nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: The current instance of TextFieldFormatDtoBigFloat\n"+
			"is improperly configured and Invalid!\n"+
			"Error=\n%v\n",
			ePrefix.String(),
			err2.Error())

		return numStr, err
	}

	var roundingSpec NumStrRoundingSpec

	roundingSpec.roundToFractionalDigits =
		txtBigFloatFieldFmtDto.NumOfFractionalDigits

	roundingSpec.roundingType =
		txtBigFloatFieldFmtDto.RoundingType

	err2 = roundingSpec.IsValidInstanceError(
		ePrefix.XCpy(
			"numStrFmtSpec"))

	if err2 != nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoFloat64 Rounding Specifications\n"+
			"are improperly configured and Invalid!\n"+
			"Error:\n%v\n",
			ePrefix.String(),
			err2.Error())

		return numStr, err
	}

	var numStrKernel NumberStrKernel

	numStrKernel,
		err = new(textFieldFormatDtoBigFloatElectron).
		getNumberStrKernel(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {
		return numStr, err
	}

	numStr,
		err = numStrKernel.FmtNumStr(
		numStrFmtSpec,
		roundingSpec,
		ePrefix.XCpy(
			"numStrKernel"))

	return numStr, err
}

// textFieldFormatDtoBigFloatAtom - Provides helper methods for
// TextFieldFormatDtoBigFloat.
type textFieldFormatDtoBigFloatAtom struct {
	lock *sync.Mutex
}

// empty
//
// Receives a pointer to an instance of
// TextFieldFormatDtoBigFloat and proceeds to set all the
// member variables to their zero or uninitialized
// states.
//
// ----------------------------------------------------------------
//
// # IMPORTANT
//
//	This method will delete and reset all pre-existing
//	data values contained within the
//	TextFieldFormatDtoBigFloat instance passed as input
//	parameter 'txtBigFloatFieldFmtDto' to their zero or
//	uninitialized states.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of TextFieldFormatDtoBigFloat.
//		All data values contained within this instance
//		will be deleted and reset to their zero or
//		uninitialized states.
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	NONE
func (txtFieldFmtDtoBigFloatAtom *textFieldFormatDtoBigFloatAtom) empty(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat) {

	if txtFieldFmtDtoBigFloatAtom.lock == nil {
		txtFieldFmtDtoBigFloatAtom.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatAtom.lock.Lock()

	defer txtFieldFmtDtoBigFloatAtom.lock.Unlock()

	if txtBigFloatFieldFmtDto == nil {

		return
	}

	txtBigFloatFieldFmtDto.LeftMarginStr = ""

	txtBigFloatFieldFmtDto.BigFloatNum.SetInt64(0)

	txtBigFloatFieldFmtDto.LeadingMinusSign = false

	txtBigFloatFieldFmtDto.NativeRoundingMode =
		big.ToNearestEven

	txtBigFloatFieldFmtDto.RoundingType =
		NumRoundType.None()

	txtBigFloatFieldFmtDto.NumOfFractionalDigits = 0

	txtBigFloatFieldFmtDto.DefaultNumStrFmt.Empty()

	txtBigFloatFieldFmtDto.FieldLength = 0

	txtBigFloatFieldFmtDto.FieldJustify = TxtJustify.None()

	txtBigFloatFieldFmtDto.RightMarginStr = ""

	return
}

// equal
//
// Compares two instances of TextFieldFormatDtoBigFloat
// and returns a boolean value signaling whether the two
// instances are equivalent in all respects.
//
// If the two instances of TextFieldFormatDtoBigFloat are
// equal, this method returns 'true'.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDtoOne		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The data values contained within this instance
//		will be compared to corresponding data values
//		contained within a second
//		TextFieldFormatDtoBigFloat instance
//		('txtBigFloatFieldFmtDtoTwo') in order to
//		determine if they are equivalent.
//
//	txtBigFloatFieldFmtDtoTwo		*TextFieldFormatDtoBigFloat
//
//		A pointer to the second of two instances of
//		TextFieldFormatDtoBigFloat. The data values
//		contained within this instance will be compared
//		to corresponding data values contained within the
//		first TextFieldFormatDtoBigFloat instance
//		('txtBigFloatFieldFmtDtoOne') in order to
//		determine if they are equivalent.
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	bool
//
//		If all the data values within input parameters
//		'txtBigFloatFieldFmtDtoOne' and
//		'txtBigFloatFieldFmtDtoTwo' are found to be
//		equivalent in all respects, this return parameter
//		will be set to 'true'.
//
//		If the compared data values are NOT equivalent,
//		this method returns 'false'.
func (txtFieldFmtDtoBigFloatAtom *textFieldFormatDtoBigFloatAtom) equal(
	txtBigFloatFieldFmtDtoOne *TextFieldFormatDtoBigFloat,
	txtBigFloatFieldFmtDtoTwo *TextFieldFormatDtoBigFloat) bool {

	if txtFieldFmtDtoBigFloatAtom.lock == nil {
		txtFieldFmtDtoBigFloatAtom.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatAtom.lock.Lock()

	defer txtFieldFmtDtoBigFloatAtom.lock.Unlock()

	if txtBigFloatFieldFmtDtoOne == nil ||
		txtBigFloatFieldFmtDtoTwo == nil {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.LeftMarginStr !=
		txtBigFloatFieldFmtDtoTwo.LeftMarginStr {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.LeadingMinusSign !=
		txtBigFloatFieldFmtDtoTwo.LeadingMinusSign {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.NativeRoundingMode !=
		txtBigFloatFieldFmtDtoTwo.NativeRoundingMode {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.RoundingType !=
		txtBigFloatFieldFmtDtoTwo.RoundingType {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.NumOfFractionalDigits !=
		txtBigFloatFieldFmtDtoTwo.NumOfFractionalDigits {

		return false
	}

	if !txtBigFloatFieldFmtDtoOne.DefaultNumStrFmt.Equal(
		&txtBigFloatFieldFmtDtoTwo.DefaultNumStrFmt) {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.FieldLength !=
		txtBigFloatFieldFmtDtoTwo.FieldLength {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.FieldJustify !=
		txtBigFloatFieldFmtDtoTwo.FieldJustify {

		return false
	}

	if txtBigFloatFieldFmtDtoOne.RightMarginStr !=
		txtBigFloatFieldFmtDtoTwo.RightMarginStr {

		return false
	}

	var bFloatNumStrOne, bFloatNumStrTwo string
	var tempBFloatOne, tempBFloatTwo big.Float

	tempBFloatOne.Copy(
		&txtBigFloatFieldFmtDtoOne.BigFloatNum)

	tempBFloatOne.SetMode(
		txtBigFloatFieldFmtDtoOne.NativeRoundingMode)

	bFloatNumStrOne = tempBFloatOne.Text(
		'f',
		txtBigFloatFieldFmtDtoOne.NumOfFractionalDigits)

	tempBFloatTwo.Copy(
		&txtBigFloatFieldFmtDtoTwo.BigFloatNum)

	tempBFloatTwo.SetMode(
		txtBigFloatFieldFmtDtoTwo.NativeRoundingMode)

	bFloatNumStrTwo = tempBFloatTwo.Text(
		'f',
		txtBigFloatFieldFmtDtoTwo.NumOfFractionalDigits)

	if bFloatNumStrOne != bFloatNumStrTwo {
		return false
	}

	return true
}

// testValidityOfTextLabelFieldFmtDto
//
// Receives a pointer to an instance of
// TextFieldFormatDtoBigFloat and performs a diagnostic
// analysis to determine if the data values contained in
// that instance are valid in all respects.
//
// If the input parameter 'txtBigFloatFieldFmtDto' is
// determined to be invalid, this method will return a
// boolean flag ('isValid') of 'false'. In addition, an
// instance of type error ('err') will be returned
// configured with an appropriate error message.
//
// If the input parameter 'txtBigFloatFieldFmtDto' is
// valid, this method will return a boolean flag
// ('isValid') of 'true' and the returned error type
// ('err') will be set to 'nil'.
//
// If txtFieldFmtDtoFloat64.DefaultNumStrFmt is invalid,
// it will be reset to the standard US (United States)
// Signed Number String Formatting Specification.
//
// All other data values in this instance will remain
// unchanged.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The data values contained in this instance will
//		be reviewed and analyzed to determine if they
//		are valid in all respects.
//
//		If txtBigFloatFieldFmtDto.DefaultNumStrFmt is
//		invalid, it will be reset to the standard US
//		(United States) Signed Number String Formatting
//		Specification.
//
//		All other data values in this instance will
//		remain unchanged.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	isValid						bool
//
//		If all data elements contained within input
//		parameter 'txtBigFloatFieldFmtDto' are judged to
//		be valid, this returned boolean value will be set
//		to 'true'. If any data values are invalid, this
//		return parameter will be set to 'false'.
//
//	error
//
//		If this method completes successfully and all the
//		data values contained in input parameter
//		'txtBigFloatFieldFmtDto' are judged to be valid,
//		the returned error Type will be set equal to
//		'nil'.
//
//		If the data values contained in input parameter
//		'txtBigFloatFieldFmtDto' are invalid, the
//		returned 'error' will be non-nil and configured
//		with an appropriate error message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtFieldFmtDtoBigFloatAtom *textFieldFormatDtoBigFloatAtom) testValidityOfTxtFieldFmtDtoBigFloat(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	isValid bool,
	err error) {

	if txtFieldFmtDtoBigFloatAtom.lock == nil {
		txtFieldFmtDtoBigFloatAtom.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatAtom.lock.Lock()

	defer txtFieldFmtDtoBigFloatAtom.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	isValid = false

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textFieldFormatDtoBigFloatAtom."+
			"testValidityOfTxtFieldFmtDtoBigFloat()",
		"")

	if err != nil {

		return isValid, err

	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtLabelFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return isValid, err
	}

	if txtBigFloatFieldFmtDto.FieldLength < -1 {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoBigFloat parameter 'FieldLength' is INVALID!\n"+
			"txtBigFloatFieldFmtDto.FieldLength has a value less than minus one (-1)\n"+
			"txtBigFloatFieldFmtDto.FieldLength = %v\n",
			ePrefix.String(),
			txtBigFloatFieldFmtDto.FieldLength)

		return isValid, err
	}

	if txtBigFloatFieldFmtDto.FieldLength > 1000000 {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoBigFloat parameter 'FieldLength' is INVALID!\n"+
			"txtBigFloatFieldFmtDto.FieldLength has a value greater than one-million (1,000,000)\n"+
			"txtBigFloatFieldFmtDto.FieldLength = %v\n",
			ePrefix.String(),
			txtBigFloatFieldFmtDto.FieldLength)

		return isValid, err
	}

	if txtBigFloatFieldFmtDto.NativeRoundingMode < 0 ||
		txtBigFloatFieldFmtDto.NativeRoundingMode >
			big.ToPositiveInf {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoBigFloat parameter 'NativeRoundingMode' is INVALID!\n"+
			"ToNearestEven\n"+
			"ToNearestAway\n"+
			"ToZero\n"+
			"AwayFromZero\n"+
			"ToNegativeInf\n"+
			"ToPositiveInf\n"+
			"ToNearestAway\n"+
			"txtBigFloatFieldFmtDto.NativeRoundingMode = '%v'\n",
			ePrefix.String(),
			txtBigFloatFieldFmtDto.NativeRoundingMode)

		return isValid, err

	}

	if !txtBigFloatFieldFmtDto.RoundingType.XIsValid() {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoBigFloat parameter 'RoundingType' is INVALID!\n"+
			"txtBigFloatFieldFmtDto.RoundingType must be set to a valid value as follows:\n"+
			" NumRoundType.NoRounding()\n"+
			" NumRoundType.HalfUpWithNegNums()\n"+
			" NumRoundType.HalfDownWithNegNums()\n"+
			" NumRoundType.HalfAwayFromZero()\n"+
			" NumRoundType.HalfTowardsZero()\n"+
			" NumRoundType.HalfToEven()\n"+
			" NumRoundType.HalfToOdd()\n"+
			" NumRoundType.Randomly()\n"+
			" NumRoundType.Floor()\n"+
			" NumRoundType.Ceiling()\n"+
			" NumRoundType.Truncate()\n"+
			" txtBigFloatFieldFmtDto.RoundingType String Value = %v\n"+
			"txtBigFloatFieldFmtDto.RoundingType Integer Value = %v\n",
			ePrefix.String(),
			txtBigFloatFieldFmtDto.RoundingType.String(),
			txtBigFloatFieldFmtDto.RoundingType.XValueInt())

		return isValid, err
	}

	if txtBigFloatFieldFmtDto.NumOfFractionalDigits < -1 {

		err = fmt.Errorf("%v\n"+
			"ERROR: TextFieldFormatDtoBigFloat parameter 'NumOfFractionalDigits' is INVALID!\n"+
			"txtBigFloatFieldFmtDto.NumOfFractionalDigits has a value less than minus one (-1)\n"+
			"txtBigFloatFieldFmtDto.NumOfFractionalDigits = %v\n",
			ePrefix.String(),
			txtBigFloatFieldFmtDto.NumOfFractionalDigits)

		return isValid, err
	}

	var numberFieldSpec NumStrNumberFieldSpec

	numberFieldSpec.fieldLength =
		txtBigFloatFieldFmtDto.FieldLength

	numberFieldSpec.fieldJustification =
		txtBigFloatFieldFmtDto.FieldJustify

	err = new(numStrFmtSpecMechanics).
		setUSDefaultSignedNumStrFmtIfNeeded(
			&txtBigFloatFieldFmtDto.DefaultNumStrFmt,
			numberFieldSpec,
			ePrefix.XCpy(
				"txtFieldFmtDtoFloat64.DefaultNumStrFmt"))

	if err != nil {

		return isValid, err

	}

	isValid = true

	return isValid, err
}

// textFieldFormatDtoBigFloatElectron - Provides helper
// methods for TextFieldFormatDtoBigFloat.
type textFieldFormatDtoBigFloatElectron struct {
	lock *sync.Mutex
}

//	getBigFloatRoundedPureNumStr
//
//	Receives a pointer to an instance of
//	TextFieldFormatDtoBigFloat ('txtBigFloatFieldFmtDto')
//	and extracts the specifications necessary to format
//	and return a rounded floating point pure number
//	string generated from a conversion performed by type
//	'NumberStrKernel'.
//
//	A rounded pure number string differs from a
//	'native' number string in that rounded pure number
//	string uses the following TextFieldFormatDtoBigFloat
//	member variables to generate a number string using
//	the conversion algorithms provided by type
//	'NumberStrKernel':
//
//		txtBigFloatFieldFmtDto.LeadingMinusSign
//		txtBigFloatFieldFmtDto.RoundingType
//		txtBigFloatFieldFmtDto.NumOfFractionalDigits
//
//	Users will note that rounded pure number strings
//	offer more flexibility than native strings when
//	attempting to conform to multinational and
//	multicultural number string formatting conventions.
//
//	The rounded floating point pure number string returned
//	by this method will:
//
//		1.	Consist entirely of numeric digit characters
//			with the following exceptions.
//
//		2. Separate integer and fractional digits with a
//		   decimal point ('.').
//
//		3.	Designate negative values with a leading or
//			trailing minus sign ('-'). Minus sign
//			placement is controlled by member variable
//			TextFieldFormatDtoFloat64.LeadingMinusSign.
//
//				Leading Minus Sign:		-1000000
//						OR
//				Trailing Minus Sign:	1000000-
//
//		4. NOT include integer separators such as commas
//		   (',') to separate integer digits by thousands.
//
//		   		  	 NOT THIS: 1,000,000
//		   Pure Number String: 1000000
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//  1. Pure number strings Do NOT include integer separators
//     (i.e. commas ',') to separate integer number strings
//     into thousands.
//
//     NOT THIS: 1,000,000
//     Pure Number String: 1000000
//
//  2. All negative numeric values processed by this method
//     will return number strings containing either a
//     leading minus sign ('-') or a trailing minus sign,
//     depending on the value of member variable:
//
//     TextFieldFormatDtoFloat64.LeadingMinusSign
//
//     Leading Minus Sign:		-1000000
//     OR
//     Trailing Minus Sign:	1000000-
//
//  3. Field Length and Field Justification are NOT used
//     when formatting rounded pure number strings.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		This instance of TextFieldFormatDtoBigFloat will
//		be converted, formatted and returned as a
//		floating point pure number string.
//
//		If this instance of TextFieldFormatDtoBigFloat
//		contains invalid data elements, an error will
//		be returned.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, this
//		string parameter will return a floating point
//		pure number string representation of the
//		big.Float value passed by input paramter,
//		'txtBigFloatFieldFmtDto'.
//
//		The returned floating point pure number string
//		will:
//
//		1.	Consist entirely of numeric digit characters
//			with the following exceptions.
//
//		2.	Separate integer and fractional digits with a
//			decimal point ('.').
//
//		3.	Designate negative values with either leading
//			or trailing minus sign ('-').
//
//		4.	NOT include integer separators such as commas
//			(',') to separate integer digits by thousands.
//
//						  NOT THIS: 1,000,000
//				Pure Number String: 1000000
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtFieldFmtDtoBigFloatElectron *textFieldFormatDtoBigFloatElectron) getBigFloatRoundedPureNumStr(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	string,
	error) {

	if txtFieldFmtDtoBigFloatElectron.lock == nil {
		txtFieldFmtDtoBigFloatElectron.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatElectron.lock.Lock()

	defer txtFieldFmtDtoBigFloatElectron.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textFieldFormatDtoBigFloatElectron."+
			"getBigFloatRoundedPureNumStr()",
		"")

	if err != nil {

		return "", err

	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return "", err
	}

	_,
		err = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return "", err

	}

	var bigFloatNumStr string

	var float64NumberStrKernel NumberStrKernel

	float64NumberStrKernel,
		err = new(NumberStrKernel).NewFromFloatValue(
		txtBigFloatFieldFmtDto.BigFloatNum,
		ePrefix.XCpy(
			"txtBigFloatFieldFmtDto.BigFloatNum"))

	if err != nil {

		return "", err

	}

	roundingSpecOne := NumStrRoundingSpec{
		roundingType:            txtBigFloatFieldFmtDto.RoundingType,
		roundToFractionalDigits: txtBigFloatFieldFmtDto.NumOfFractionalDigits,
	}

	bigFloatNumStr,
		err = float64NumberStrKernel.FmtSignedPureNumberStr(
		".",
		txtBigFloatFieldFmtDto.LeadingMinusSign,
		-1,
		TxtJustify.Right(),
		roundingSpecOne,
		ePrefix.XCpy(
			"bigFloatNumStr<-float64NumberStrKernel"))

	return bigFloatNumStr, err
}

//	getBigFloatNativeNumStr
//
//	Receives a pointer to an instance of
//	TextFieldFormatDtoBigFloat and extracts the
//	specifications necessary to format and return a
//	floating point, native number string.
//
//	A native number string is generated using the
//	Text function from the Golang 'big' package or
//	library ('big.Float.Text()'). Formatting options are
//	therefore limited.
//
//	The floating point native number string returned
//	by this method will therefore:
//
//	 1.	Consist entirely of numeric digit characters with
//		the following exceptions.
//
//	 2.	Separate integer and fractional digits with a
//		decimal point ('.').
//
//	 3.	Designate negative values with a leading minus
//		sign ('-').
//
//	 4.	NOT include integer separators such as commas
//		(',') to separate integer digits by thousands.
//
//							NOT THIS: 1,000,000
//				Native Number String: 1000000
//
// ----------------------------------------------------------------
//
// # BE ADVISED
//
//  1. Native number strings Do NOT include integer
//     separators (i.e. commas ',') to separate integer
//     number strings into thousands.
//
//     NOT THIS: 1,000,000
//     Native Number String: 1000000
//
//  2. Note that the placement of the leading minus sign
//     is fixed and completely controlled by the Golang
//     'big' package. Trailing minus signs are therefore
//     NOT supported. Only Leading minus signs will be
//     presented for negative numeric values.
//
//  3. The type of Rounding algorithm applied when
//     generating a native number string is controlled
//     by the Mode parameter contained in the
//     'txtBigFloatFieldFmtDto' instance of
//     TextFieldFormatDtoBigFloat. The member variable
//     is named:
//
//     txtBigFloatFieldFmtDto.NativeRoundingMode
//
//  4. The number of decimal digits to the right of the
//     decimal point returned in a native number string
//     is controlled by the 'txtBigFloatFieldFmtDto'
//     parameter 'NumOfFractionalDigits'. If this
//     parameter is set to minus one (-1), all available
//     fractional digits in the big.Float numeric value
//     will be returned in the native number string.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		This instance of TextFieldFormatDtoBigFloat will
//		be converted, formatted and returned as a
//		floating point native number string.
//
//		If this instance of TextFieldFormatDtoBigFloat
//		contains invalid data elements, an error will
//		be returned.
//
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	string
//
//		If this method completes successfully, this
//		string parameter will return a floating point
//		native number string representation of the
//		big.Float value passed by input paramter,
//		'txtBigFloatFieldFmtDto'.
//
//		The returned floating point native number string
//		will:
//
//		1.	Consist entirely of numeric digit characters
//			with the following exceptions.
//
//		2.	Separate integer and fractional digits with a
//			decimal point ('.').
//
//		3.	Designate negative values with a leading minus
//			sign ('-').
//
//		4.	NOT include integer separators such as commas
//			(',') to separate integer digits by thousands.
//
//							NOT THIS: 1,000,000
//				Native Number String: 1000000
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtFieldFmtDtoBigFloatElectron *textFieldFormatDtoBigFloatElectron) getBigFloatNativeNumStr(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	string,
	error) {

	if txtFieldFmtDtoBigFloatElectron.lock == nil {
		txtFieldFmtDtoBigFloatElectron.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatElectron.lock.Lock()

	defer txtFieldFmtDtoBigFloatElectron.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textFieldFormatDtoBigFloatElectron."+
			"getBigFloatNativeNumStr()",
		"")

	if err != nil {

		return "", err

	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return "", err
	}

	_,
		err = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return "", err

	}

	txtBigFloatFieldFmtDto.BigFloatNum.SetMode(
		txtBigFloatFieldFmtDto.NativeRoundingMode)

	numStr := txtBigFloatFieldFmtDto.BigFloatNum.Text(
		'f',
		txtBigFloatFieldFmtDto.NumOfFractionalDigits)

	return numStr, err
}

//	getNumberStrKernel
//
//	Returns an instance of NumberStrKernel configured
//	with the big.Float numeric value contained within
//	input parameter 'txtBigFloatFieldFmtDto', an instance
//	of type TextFieldFormatDtoBigFloat.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	txtBigFloatFieldFmtDto		*TextFieldFormatDtoBigFloat
//
//		A pointer to an instance of
//		TextFieldFormatDtoBigFloat.
//
//		The big.Float numeric value contained in this
//		instance of TextFieldFormatDtoBigFloat will
//		be used to populate the returned instance
//		of NumberStrKernel.
//
//		If this instance of TextFieldFormatDtoBigFloat
//		contains invalid data elements, an error will
//		be returned.
//
//	errPrefDto					*ePref.ErrPrefixDto
//
//		This object encapsulates an error prefix string
//		which is included in all returned error
//		messages. Usually, it contains the name of the
//		calling method or methods listed as a function
//		chain.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		Type ErrPrefixDto is included in the 'errpref'
//		software package:
//			"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	NumberStrKernel
//
//		If this method completes successfully, an
//		instance of NumberStrKernel will be returned
//		configured with the numeric value contained
//		within the TextFieldFormatDtoBigFloat input
//		parameter, 'txtBigFloatFieldFmtDto'.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'. If
//		errors are encountered during processing, the
//		returned error Type will encapsulate an error
//		message.
//
//		If an error message is returned, the text value
//		for input parameter 'errPrefDto' (error prefix)
//		will be prefixed or attached at the beginning of
//		the error message.
func (txtFieldFmtDtoBigFloatElectron *textFieldFormatDtoBigFloatElectron) getNumberStrKernel(
	txtBigFloatFieldFmtDto *TextFieldFormatDtoBigFloat,
	errPrefDto *ePref.ErrPrefixDto) (
	NumberStrKernel,
	error) {

	if txtFieldFmtDtoBigFloatElectron.lock == nil {
		txtFieldFmtDtoBigFloatElectron.lock = new(sync.Mutex)
	}

	txtFieldFmtDtoBigFloatElectron.lock.Lock()

	defer txtFieldFmtDtoBigFloatElectron.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto

	var err error

	newNumberStrKernel := NumberStrKernel{}

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewFromErrPrefDto(
		errPrefDto,
		"textFieldFormatDtoBigFloatElectron."+
			"getNumberStrKernel()",
		"")

	if err != nil {

		return newNumberStrKernel, err

	}

	if txtBigFloatFieldFmtDto == nil {

		err = fmt.Errorf("%v\n"+
			"ERROR: Input parameter 'txtBigFloatFieldFmtDto' is a nil pointer!\n",
			ePrefix.String())

		return newNumberStrKernel, err
	}

	_,
		err = new(textFieldFormatDtoBigFloatAtom).
		testValidityOfTxtFieldFmtDtoBigFloat(
			txtBigFloatFieldFmtDto,
			ePrefix.XCpy(
				"txtBigFloatFieldFmtDto"))

	if err != nil {

		return newNumberStrKernel, err

	}

	newNumberStrKernel,
		err = new(NumberStrKernel).NewFromFloatValue(
		txtBigFloatFieldFmtDto.BigFloatNum,
		ePrefix.XCpy(
			"txtBigFloatFieldFmtDto.BigFloatNum"))

	if err != nil {

		return newNumberStrKernel, err

	}

	err = newNumberStrKernel.Round(
		txtBigFloatFieldFmtDto.RoundingType,
		txtBigFloatFieldFmtDto.NumOfFractionalDigits,
		ePrefix.XCpy(
			"newNumberStrKernel<-"+
				"txtBigFloatFieldFmtDto"))

	return newNumberStrKernel, err
}
