package strmech

import (
	"fmt"
	ePref "github.com/MikeAustin71/errpref"
	"strings"
	"sync"
)

type FileOpenConfig struct {
	isInitialized bool

	fileOpenType FileOpenType

	fileOpenModes []FileOpenMode

	lock *sync.Mutex
}

// CopyIn
//
// Receives a FileOpenConfig instance and copies all the
// data fields to the current FileOpenConfig instance.
// When complete, both the incoming and current
// FileOpenConfig instances will be identical.
//
// The type of copy operation performed is a 'deep copy'.
func (fOpenCfg *FileOpenConfig) CopyIn(
	fOpStat2 *FileOpenConfig) {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpStat2.fileOpenModes == nil {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 0)
	}

	fOpenCfg.isInitialized = fOpStat2.isInitialized
	fOpenCfg.fileOpenType = fOpStat2.fileOpenType

	lenFOpStat2FOpenModes := len(fOpStat2.fileOpenModes)

	if lenFOpStat2FOpenModes == 0 {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 1)
		fOpStat2.fileOpenModes[0] = FOpenMode.ModeNone()
		lenFOpStat2FOpenModes = 1
	}

	fOpenCfg.fileOpenModes = make([]FileOpenMode, lenFOpStat2FOpenModes)

	for i := 0; i < lenFOpStat2FOpenModes; i++ {
		fOpenCfg.fileOpenModes[i] = fOpStat2.fileOpenModes[i]
	}

}

// CopyOut - Creates and returns a deep copy of the current
// FileOpenConfig instance.
func (fOpenCfg *FileOpenConfig) CopyOut() FileOpenConfig {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	fOpStat2 := FileOpenConfig{}
	fOpStat2.isInitialized = fOpenCfg.isInitialized
	fOpStat2.fileOpenType = fOpenCfg.fileOpenType
	lenFOpenModes := len(fOpenCfg.fileOpenModes)

	if lenFOpenModes == 0 {
		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())
		lenFOpenModes = 1
	}

	fOpStat2.fileOpenModes = make([]FileOpenMode, lenFOpenModes)

	for i := 0; i < lenFOpenModes; i++ {
		fOpStat2.fileOpenModes[i] = fOpenCfg.fileOpenModes[i]
	}

	return fOpStat2
}

// Empty - ReInitializes the current FileOpenConfig instance to
// empty or zero values.
func (fOpenCfg *FileOpenConfig) Empty() {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	fOpenCfg.isInitialized = false

	fOpenCfg.fileOpenType = FOpenType.TypeNone()

	fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)

	fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())

}

// Equal - Returns 'true' if the incoming FileOpenConfig instance
// is equal in all respects to the current FileOpenConfig instance.
func (fOpenCfg *FileOpenConfig) Equal(fOpStat2 *FileOpenConfig) bool {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpStat2.fileOpenModes == nil {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpenCfg.isInitialized != fOpStat2.isInitialized {
		return false
	}

	lenfOpStat1 := len(fOpenCfg.fileOpenModes)

	lenfOpStat2 := len(fOpStat2.fileOpenModes)

	if lenfOpStat1 != lenfOpStat2 {
		return false
	}

	if fOpenCfg.fileOpenType != fOpStat2.fileOpenType {
		return false
	}

	for i := 0; i < lenfOpStat1; i++ {
		isFound := false

		for j := 0; j < lenfOpStat1; j++ {
			if fOpStat2.fileOpenModes[j] == fOpenCfg.fileOpenModes[i] {
				isFound = true
			}
		}

		if !isFound {
			return false
		}
	}

	return true
}

// GetCompositeFileOpenCode
//
// Returns the composite 'file open' code. This code
// is generated by or'ing together the stored single
// FileOpenType value and zero or more FileOpenMode
// values.
func (fOpenCfg *FileOpenConfig) GetCompositeFileOpenCode() (
	int, error) {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	ePrefix := "FileOpenConfig.GetCompositeFileOpenCode() "

	if !fOpenCfg.isInitialized {
		return -1,
			fmt.Errorf("%v\n"+
				"Error: The current FileOpenConfig instance is INVALID!\n",
				ePrefix)
	}

	if fOpenCfg.fileOpenType == FileOpenType(0).TypeNone() {

		return -1,
			fmt.Errorf("%v\n"+
				"Error: The stored FileOpenType == 'None'.\n"+
				"A valid FileOpenType is required!\n",
				ePrefix)
	}

	err := fOpenCfg.fileOpenType.IsValid()

	if err != nil {
		return -1,
			fmt.Errorf("%v\n"+
				"Error: The stored FileOpenType is INVALID!\n"+
				"FileOpenType='%v' ",
				ePrefix,
				fOpenCfg.fileOpenType.Value())
	}

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	lenFileOpenModes := len(fOpenCfg.fileOpenModes)

	if lenFileOpenModes == 0 {
		return fOpenCfg.fileOpenType.Value(), nil
	}

	if lenFileOpenModes == 1 &&
		fOpenCfg.fileOpenModes[0] == FOpenMode.ModeNone() {

		return fOpenCfg.fileOpenType.Value(), nil

	}

	fileOpenVal := fOpenCfg.fileOpenType.Value()

	for i := 0; i < lenFileOpenModes; i++ {
		fileOpenVal = fileOpenVal | fOpenCfg.fileOpenModes[i].Value()
	}

	return fileOpenVal, nil
}

// GetFileOpenModes
// Returns an array of stored FileOpenMode values
func (fOpenCfg *FileOpenConfig) GetFileOpenModes() []FileOpenMode {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if len(fOpenCfg.fileOpenModes) == 0 {
		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())
	}

	resultAry := make([]FileOpenMode, 0)

	resultAry = append(resultAry, fOpenCfg.fileOpenModes...)

	return resultAry
}

// GetFileOpenType - Returns the stored FileOpenType value.
func (fOpenCfg *FileOpenConfig) GetFileOpenType() FileOpenType {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	return fOpenCfg.fileOpenType
}

// GetFileOpenNarrativeText - Returns a string with the File Open Type and
// File Open Modes expressed as descriptive text.
func (fOpenCfg *FileOpenConfig) GetFileOpenNarrativeText() string {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	sb := strings.Builder{}
	sb.Grow(300)

	err := fOpenCfg.fileOpenType.IsValid()

	if err == nil {
		typeStr := fOpenCfg.fileOpenType.String()
		typeStr = strings.Replace(typeStr, "Type", "", 1)
		sb.WriteString("File Open Type: " + typeStr + " ")
	} else {
		sb.WriteString("File Open Type: INVALID!!! ")
	}

	if fOpenCfg.fileOpenModes == nil ||
		len(fOpenCfg.fileOpenModes) == 0 {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
	}

	sb.WriteString(" -File Open Modes: ")

	for i := 0; i < len(fOpenCfg.fileOpenModes); i++ {

		if i > 0 {
			sb.WriteString("; ")
		}

		err = fOpenCfg.fileOpenModes[i].IsValid()

		if err != nil {
			sb.WriteString(fmt.Sprintf("Index=%v INVALID!", i))
		} else {
			modeStr := fOpenCfg.fileOpenModes[i].String()
			modeStr = strings.Replace(modeStr, "Mode", "", 1)
			sb.WriteString(fmt.Sprintf("%s", modeStr))
		}

	}

	return sb.String()
}

// IsValid - If the current FileOpenConfig instance is valid and properly
// initialized, this method returns nil. If the current FileOpenConfig
// instance is invalid, this method returns an error.
func (fOpenCfg *FileOpenConfig) IsValid() error {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	ePrefix := "FileOpenConfig.IsValid() "

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if !fOpenCfg.isInitialized {
		return fmt.Errorf("%v\n"+
			"Error: The current FileOpenConfig instance has\n"+
			"NOT been properly initialized.\n",
			ePrefix)
	}

	err := fOpenCfg.fileOpenType.IsValid()

	if err != nil {
		return fmt.Errorf("%v\n"+
			"Error: The File Open Type is INVALID!.\n"+
			"Error=\n%v\n",
			ePrefix,
			err.Error())
	}

	lenFileOpenModes := len(fOpenCfg.fileOpenModes)

	if fOpenCfg.fileOpenType == FOpenType.TypeNone() &&
		lenFileOpenModes > 1 {

		return fmt.Errorf("%v\n"+
			"Error: Current FileOpenConfig has Type='None'\n"+
			"and multiple File Open Modes!\n"+
			"Number Of File Open Modes = %v\n",
			ePrefix,
			lenFileOpenModes)
	}

	if fOpenCfg.fileOpenType == FOpenType.TypeNone() &&
		lenFileOpenModes == 1 &&
		fOpenCfg.fileOpenModes[0] != FileOpenMode(0).ModeNone() {

		return fmt.Errorf("%v\n"+
			"Error: Current FileOpenConfig has Type='None' and "+
			"a valid File Open Mode\n",
			ePrefix)
	}

	if fOpenCfg.fileOpenType != FOpenType.TypeNone() &&
		lenFileOpenModes > 1 {

		for i := 0; i < lenFileOpenModes; i++ {
			if fOpenCfg.fileOpenModes[i] == FileOpenMode(0).ModeNone() {

				return fmt.Errorf("%v\n"+
					"Error: The File Open Status has multiple File Open Modes\n"+
					"one of which is 'None'. Resolve this conflict.\n",
					ePrefix)
			}
		}

	}

	for i := 0; i < lenFileOpenModes; i++ {

		err := fOpenCfg.fileOpenModes[i].IsValid()

		if err != nil {
			return fmt.Errorf("%v\n"+
				"Error: A File Open Mode is INVALID!\n"+
				"Index='%v'\n"+
				"Invalid Error=\n%v\n ",
				ePrefix,
				i,
				err.Error())
		}

	}

	return nil
}

// New
//
// Creates and returns a fully initialized FileOpenConfig
// instance which encapsulates a "File Open" parameter or
// code.
//
// To create a File Open parameter, two components are
// required:
//
//  1. A FileOpenType
//
//     AND
//
//  2. A FileOpenMode
//
//     FileOpenType:
//
//     In order to open a file, exactly one of the
//     following File Open Codes MUST be specified:
//
//     FileOpenType(0).TypeReadOnly()
//     FileOpenType(0).TypeWriteOnly()
//     FileOpenType(0).TypeReadWrite()
//
//     FileOpenMode:
//
//     In addition to a 'FileOpenType', a File Open Mode
//     is also required. Zero or more of the following
//     File Open Mode codes may optionally be specified
//     to better control file open behavior.
//
//     FileOpenMode(0).ModeAppend()
//     FileOpenMode(0).ModeCreate()
//     FileOpenMode(0).ModeExclusive()
//     FileOpenMode(0).ModeSync()
//     FileOpenMode(0).ModeTruncate()
//
// The composite file open code is created internally by
// or'ing together the FileOpenType and FileOpenMode
// codes.
//
// Reference CONSTANTS:
//
//	https://golang.org/pkg/os/
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		This empty interface must be convertible to one
//		of the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
//	fOpenType					FileOpenType
//
//		The FileOpenType used to open a file.
//		FileOpenType is an enumeration. Valid options are
//		listed below using shorthand notation:
//
//			FOpenType.TypeReadOnly()
//			FOpenType.TypeWriteOnly()
//			FOpenType.TypeReadWrite()
//
//	fOpenModes					...FileOpenMode
//
//		Zero or more FileOpenMode instances which will be
//		or'd with the input parameter 'fOpenType' in order
//		to generate the composite 'file open' code which
//		will be used to open a file.  If no File Open Modes
//		will be used, the user should pass
//		'FileOpenMode(0).None()' or pass nothing for this
//		parameter.
//
//		FileOpenMode is an enumeration. Valid options are
//		listed below using the abbreviated notation:
//
//			FOpenMode.ModeNone()
//			FOpenMode.ModeAppend()
//			FOpenMode.ModeCreate()
//			FOpenMode.ModeExclusive()
//			FOpenMode.ModeSync()
//			FOpenMode.ModeTruncate()
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	FileOpenConfig
//
//	If successful, this method will return a new, fully
//	initialized instance of FileOpenConfig. The type
//	'FileOpenConfig' creates and encapsulates the file
//	open code required by low-level file open methods.
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an
//		appropriate error message. This returned error
//	 	message will incorporate the method chain and
//	 	text passed by input parameter, 'errorPrefix'.
//	 	The 'errorPrefix' text will be prefixed or
//	 	attached to the	beginning of the error message.
func (fOpenCfg *FileOpenConfig) New(
	errorPrefix interface{},
	fOpenType FileOpenType,
	fOpenModes ...FileOpenMode) (
	FileOpenConfig,
	error) {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"FileOpenConfig."+
			"New()",
		"")

	if err != nil {
		return FileOpenConfig{}, err
	}

	err = fOpenType.IsValid()

	if err != nil {

		return FileOpenConfig{},
			fmt.Errorf("%v\n"+
				"Error: Input parameter 'fOpenType' is INVALID!\n"+
				"fOpenType='%v'\n"+
				"Error=\n%v\n",
				ePrefix.String(),
				fOpenType.String(),
				err.Error())
	}

	resultFOpenStatus := FileOpenConfig{}

	resultFOpenStatus.fileOpenType = fOpenType

	resultFOpenStatus.fileOpenModes = make([]FileOpenMode, 0)

	if len(fOpenModes) == 0 {

		resultFOpenStatus.fileOpenModes =
			append(
				resultFOpenStatus.fileOpenModes,
				FOpenMode.ModeNone())

		resultFOpenStatus.isInitialized = true

		return resultFOpenStatus, nil
	}

	for idx, mode := range fOpenModes {

		err = mode.IsValid()

		if err != nil {
			return FileOpenConfig{},
				fmt.Errorf("%v\n"+
					"Error: Input parameter 'fOpenModes' contains an invalid FileOpenMode.\n"+
					"Index= '%v'\n"+
					"mode= '%v'\n"+
					"Error= \n%v\n",
					ePrefix.String(),
					idx,
					mode,
					err.Error())
		}

		resultFOpenStatus.fileOpenModes = append(resultFOpenStatus.fileOpenModes, mode)

	}

	resultFOpenStatus.isInitialized = true

	return resultFOpenStatus, nil
}

// SetFileOpenType
//
// Receives an input parameter 'fOpenType' which is used
// to set the internal stored FileOpenType for the
// current FileOpenConfig instance.
//
// FileOpenType:
//
// In order to open a file, exactly one of the following
// File Open Codes MUST be specified:
//
//	FileOpenType(0).TypeNone()	Invalid. Used to clear
//								the current code.
//	FileOpenType(0).TypeReadOnly()
//	FileOpenType(0).TypeWriteOnly()
//	FileOpenType(0).TypeReadWrite()
//
// Abbreviated File Open Codes may be written using the
// following notation:
//
//	FOpenType.TypeNone()	Invalid. Used to clear
//							the current code.
//	FOpenType.TypeReadOnly()
//	FOpenType.TypeWriteOnly()
//	FOpenType.TypeReadWrite()
//
// ----------------------------------------------------------------
//
// # IMPORTANT
//
//	Setting File Open Type to FileOpenType(0).TypeNone()
//	will clear the File Open Type and File Open Modes
//	for the current instance of FileOpenConfig.
//
//	Setting File Open Type to FileOpenType(0).TypeNone()
//	will also leave the current instance of
//	FileOpenConfig in an invalid state.
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//		fOpenType					FileOpenType
//
//			This FileOpenType value is used to set the
//			internal stored FileOpenType for the current
//			FileOpenConfig instance.
//
//			FileOpenType is an enumeration Valid File Open
//			Type codes are listed as follows:
//
//
//				FileOpenType(0).TypeNone()	Invalid. Used to clear
//											the current code.
//				FileOpenType(0).TypeReadOnly()
//				FileOpenType(0).TypeWriteOnly()
//				FileOpenType(0).TypeReadWrite()
//
//			File Open Codes may also be configured using the
//			following abbreviated notation:
//
//				FOpenType.TypeNone()	Invalid. Used to clear
//										the current code.
//	  		FOpenType.TypeReadOnly()
//	  		FOpenType.TypeWriteOnly()
//	  		FOpenType.TypeReadWrite()
//
//		errorPrefix					interface{}
//
//			This object encapsulates error prefix text which
//			is included in all returned error messages.
//			Usually, it contains the name of the calling
//			method or methods listed as a method or function
//			chain of execution.
//
//			If no error prefix information is needed, set
//			this parameter to 'nil'.
//
//			This empty interface must be convertible to one
//			of the following types:
//
//			1.	nil
//					A nil value is valid and generates an
//					empty collection of error prefix and
//					error context information.
//
//			2.	string
//					A string containing error prefix
//					information.
//
//			3.	[]string
//					A one-dimensional slice of strings
//					containing error prefix information.
//
//			4.	[][2]string
//					A two-dimensional slice of strings
//			   		containing error prefix and error
//			   		context information.
//
//			5.	ErrPrefixDto
//					An instance of ErrPrefixDto.
//					Information from this object will
//					be copied for use in error and
//					informational messages.
//
//			6.	*ErrPrefixDto
//					A pointer to an instance of
//					ErrPrefixDto. Information from
//					this object will be copied for use
//					in error and informational messages.
//
//			7.	IBasicErrorPrefix
//					An interface to a method
//					generating a two-dimensional slice
//					of strings containing error prefix
//					and error context information.
//
//			If parameter 'errorPrefix' is NOT convertible
//			to one of the valid types listed above, it will
//			be considered invalid and trigger the return of
//			an error.
//
//			Types ErrPrefixDto and IBasicErrorPrefix are
//			included in the 'errpref' software package:
//				"github.com/MikeAustin71/errpref".
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an
//		appropriate error message. This returned error
//	 	message will incorporate the method chain and
//	 	text passed by input parameter, 'errorPrefix'.
//	 	The 'errorPrefix' text will be prefixed or
//	 	attached to the	beginning of the error message.
func (fOpenCfg *FileOpenConfig) SetFileOpenType(
	fOpenType FileOpenType,
	errorPrefix interface{}) error {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"FileOpenConfig."+
			"SetFileOpenType()",
		"")

	if err != nil {
		return err
	}

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpenType == FOpenType.TypeNone() {

		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)

		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()

		fOpenCfg.fileOpenType = FOpenType.TypeNone()

		fOpenCfg.isInitialized = false

		return nil
	}

	err = fOpenType.IsValid()

	if err != nil {
		return fmt.Errorf("%v\n"+
			"Input parameter 'fOpenType' is INVALID!\n"+
			"fOpenType='%v'\n",
			ePrefix.String(),
			fOpenType.Value())
	}

	fOpenCfg.fileOpenType = fOpenType

	fOpenCfg.isInitialized = true

	return nil
}

// SetFileOpenModes
//
// Receives a series of FileOpenMode instances and
// replaces the internal stored FileOpenMode values for
// this FileOpenConfig instance.
//
// To clear the current internal FileOpenMode values,
// pass nothing as an input parameter or pass the value
// FileOpenMode(0).None().
//
// ----------------------------------------------------------------
//
// # Input Parameters
//
//	errorPrefix					interface{}
//
//		This object encapsulates error prefix text which
//		is included in all returned error messages.
//		Usually, it contains the name of the calling
//		method or methods listed as a method or function
//		chain of execution.
//
//		If no error prefix information is needed, set
//		this parameter to 'nil'.
//
//		This empty interface must be convertible to one
//		of the following types:
//
//		1.	nil
//				A nil value is valid and generates an
//				empty collection of error prefix and
//				error context information.
//
//		2.	string
//				A string containing error prefix
//				information.
//
//		3.	[]string
//				A one-dimensional slice of strings
//				containing error prefix information.
//
//		4.	[][2]string
//				A two-dimensional slice of strings
//		   		containing error prefix and error
//		   		context information.
//
//		5.	ErrPrefixDto
//				An instance of ErrPrefixDto.
//				Information from this object will
//				be copied for use in error and
//				informational messages.
//
//		6.	*ErrPrefixDto
//				A pointer to an instance of
//				ErrPrefixDto. Information from
//				this object will be copied for use
//				in error and informational messages.
//
//		7.	IBasicErrorPrefix
//				An interface to a method
//				generating a two-dimensional slice
//				of strings containing error prefix
//				and error context information.
//
//		If parameter 'errorPrefix' is NOT convertible
//		to one of the valid types listed above, it will
//		be considered invalid and trigger the return of
//		an error.
//
//		Types ErrPrefixDto and IBasicErrorPrefix are
//		included in the 'errpref' software package:
//			"github.com/MikeAustin71/errpref".
//
//	fOpenModes 					...FileOpenMode
//
//		This is a variadic argument consisting of a
//		variable number of File Open Modes (one or more
//		FileOpenMode objects).
//
//		FileOpenMode is an enumeration. Valid File Open
//		Modes are listed as follows:
//
//			FileOpenMode(0).ModeNone()
//			FileOpenMode(0).ModeAppend()
//			FileOpenMode(0).ModeCreate()
//			FileOpenMode(0).ModeExclusive()
//			FileOpenMode(0).ModeSync()
//			FileOpenMode(0).ModeTruncate()
//
//		These enumeration values may also be accessed
//		using the following shorthand notation:
//
//			FOpenMode.ModeNone()
//			FOpenMode.ModeAppend()
//			FOpenMode.ModeCreate()
//			FOpenMode.ModeExclusive()
//			FOpenMode.ModeSync()
//			FOpenMode.ModeTruncate()
//
// ----------------------------------------------------------------
//
// # Return Values
//
//	error
//
//		If this method completes successfully, the
//		returned error Type is set equal to 'nil'.
//
//		If errors are encountered during processing, the
//		returned error Type will encapsulate an
//		appropriate error message. This returned error
//	 	message will incorporate the method chain and
//	 	text passed by input parameter, 'errorPrefix'.
//	 	The 'errorPrefix' text will be prefixed or
//	 	attached to the	beginning of the error message.
func (fOpenCfg *FileOpenConfig) SetFileOpenModes(
	errorPrefix interface{},
	fOpenModes ...FileOpenMode) error {

	if fOpenCfg.lock == nil {
		fOpenCfg.lock = new(sync.Mutex)
	}

	fOpenCfg.lock.Lock()

	defer fOpenCfg.lock.Unlock()

	var ePrefix *ePref.ErrPrefixDto
	var err error

	ePrefix,
		err = ePref.ErrPrefixDto{}.NewIEmpty(
		errorPrefix,
		"FileOpenConfig."+
			"SetFileOpenModes()",
		"")

	if err != nil {
		return err
	}

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
		return nil
	}

	lenFOpenModes := len(fOpenModes)

	if lenFOpenModes == 0 {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
		return nil
	}

	fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)

	for idx, fOpenMode := range fOpenModes {

		err = fOpenMode.IsValid()

		if err != nil {

			fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)

			fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()

			return fmt.Errorf("%v\n"+
				"Error: File Open Mode INVALID!\n"+
				"index='%v'\n"+
				"Error=\n%v\n",
				ePrefix.String(),
				idx,
				err.Error())
		}

		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, fOpenMode)
	}

	err = fOpenCfg.fileOpenType.IsValid()

	if err == nil {
		fOpenCfg.isInitialized = true
	}

	return nil
}
