package strmech

import (
	"errors"
	"fmt"
	"strings"
)

type FileOpenConfig struct {
	isInitialized bool

	fileOpenType FileOpenType

	fileOpenModes []FileOpenMode
}

// CopyIn - Receives a FileOpenConfig instance and copies all the data
// fields to the current FileOpenConfig instance. When complete, both
// the incoming and current FileOpenConfig instances will be identical.
//
// The type of copy operation performed is a 'deep copy'.
func (fOpenCfg *FileOpenConfig) CopyIn(fOpStat2 *FileOpenConfig) {

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpStat2.fileOpenModes == nil {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 0)
	}

	fOpenCfg.isInitialized = fOpStat2.isInitialized
	fOpenCfg.fileOpenType = fOpStat2.fileOpenType

	lenFOpStat2FOpenModes := len(fOpStat2.fileOpenModes)

	if lenFOpStat2FOpenModes == 0 {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 1)
		fOpStat2.fileOpenModes[0] = FOpenMode.ModeNone()
		lenFOpStat2FOpenModes = 1
	}

	fOpenCfg.fileOpenModes = make([]FileOpenMode, lenFOpStat2FOpenModes)

	for i := 0; i < lenFOpStat2FOpenModes; i++ {
		fOpenCfg.fileOpenModes[i] = fOpStat2.fileOpenModes[i]
	}

}

// CopyOut - Creates and returns a deep copy of the current
// FileOpenConfig instance.
func (fOpenCfg *FileOpenConfig) CopyOut() FileOpenConfig {

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	fOpStat2 := FileOpenConfig{}
	fOpStat2.isInitialized = fOpenCfg.isInitialized
	fOpStat2.fileOpenType = fOpenCfg.fileOpenType
	lenFOpenModes := len(fOpenCfg.fileOpenModes)

	if lenFOpenModes == 0 {
		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())
		lenFOpenModes = 1
	}

	fOpStat2.fileOpenModes = make([]FileOpenMode, lenFOpenModes)

	for i := 0; i < lenFOpenModes; i++ {
		fOpStat2.fileOpenModes[i] = fOpenCfg.fileOpenModes[i]
	}

	return fOpStat2
}

// Empty - ReInitializes the current FileOpenConfig instance to
// empty or zero values.
func (fOpenCfg *FileOpenConfig) Empty() {

	fOpenCfg.isInitialized = false

	fOpenCfg.fileOpenType = FOpenType.TypeNone()

	fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)

	fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())

}

// Equal - Returns 'true' if the incoming FileOpenConfig instance
// is equal in all respects to the current FileOpenConfig instance.
func (fOpenCfg *FileOpenConfig) Equal(fOpStat2 *FileOpenConfig) bool {

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpStat2.fileOpenModes == nil {
		fOpStat2.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpenCfg.isInitialized != fOpStat2.isInitialized {
		return false
	}

	lenfOpStat1 := len(fOpenCfg.fileOpenModes)

	lenfOpStat2 := len(fOpStat2.fileOpenModes)

	if lenfOpStat1 != lenfOpStat2 {
		return false
	}

	if fOpenCfg.fileOpenType != fOpStat2.fileOpenType {
		return false
	}

	for i := 0; i < lenfOpStat1; i++ {
		isFound := false

		for j := 0; j < lenfOpStat1; j++ {
			if fOpStat2.fileOpenModes[j] == fOpenCfg.fileOpenModes[i] {
				isFound = true
			}
		}

		if !isFound {
			return false
		}
	}

	return true
}

// GetCompositeFileOpenCode - Returns the composite 'file open' code. This code
// is generated by or'ing together the stored single FileOpenType value and zero
// or more FileOpenMode values.
func (fOpenCfg *FileOpenConfig) GetCompositeFileOpenCode() (int, error) {

	ePrefix := "FileOpenConfig.GetCompositeFileOpenCode() "

	if !fOpenCfg.isInitialized {
		return -1,
			errors.New(ePrefix + "Error: The current FileOpenConfig instance is INVALID!")
	}

	if fOpenCfg.fileOpenType == FileOpenType(0).TypeNone() {
		return -1,
			errors.New(ePrefix + "Error: The stored FileOpenType == 'None'. A valid FileOpenType is required!")
	}

	err := fOpenCfg.fileOpenType.IsValid()

	if err != nil {
		return -1,
			fmt.Errorf(ePrefix+
				"Error: The stored FileOpenType is INVALID! FileOpenType='%v' ",
				fOpenCfg.fileOpenType.Value())
	}

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	lenFileOpenModes := len(fOpenCfg.fileOpenModes)

	if lenFileOpenModes == 0 {
		return fOpenCfg.fileOpenType.Value(), nil
	}

	if lenFileOpenModes == 1 &&
		fOpenCfg.fileOpenModes[0] == FOpenMode.ModeNone() {

		return fOpenCfg.fileOpenType.Value(), nil

	}

	fileOpenVal := fOpenCfg.fileOpenType.Value()

	for i := 0; i < lenFileOpenModes; i++ {
		fileOpenVal = fileOpenVal | fOpenCfg.fileOpenModes[i].Value()
	}

	return fileOpenVal, nil
}

// GetFileOpenModes - Returns a array of stored FileOpenMode values
func (fOpenCfg *FileOpenConfig) GetFileOpenModes() []FileOpenMode {

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if len(fOpenCfg.fileOpenModes) == 0 {
		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, FOpenMode.ModeNone())
	}

	resultAry := make([]FileOpenMode, 0)

	resultAry = append(resultAry, fOpenCfg.fileOpenModes...)

	return resultAry
}

// GetFileOpenType - Returns the stored FileOpenType value.
func (fOpenCfg *FileOpenConfig) GetFileOpenType() FileOpenType {

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	return fOpenCfg.fileOpenType
}

// GetFileOpenNarrativeText - Returns a string with the File Open Type and
// File Open Modes expressed as descriptive text.
func (fOpenCfg *FileOpenConfig) GetFileOpenNarrativeText() string {

	sb := strings.Builder{}
	sb.Grow(300)

	err := fOpenCfg.fileOpenType.IsValid()

	if err == nil {
		typeStr := fOpenCfg.fileOpenType.String()
		typeStr = strings.Replace(typeStr, "Type", "", 1)
		sb.WriteString("File Open Type: " + typeStr + " ")
	} else {
		sb.WriteString("File Open Type: INVALID!!! ")
	}

	if fOpenCfg.fileOpenModes == nil ||
		len(fOpenCfg.fileOpenModes) == 0 {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
	}

	sb.WriteString(" -File Open Modes: ")

	for i := 0; i < len(fOpenCfg.fileOpenModes); i++ {

		if i > 0 {
			sb.WriteString("; ")
		}

		err = fOpenCfg.fileOpenModes[i].IsValid()

		if err != nil {
			sb.WriteString(fmt.Sprintf("Index=%v INVALID!", i))
		} else {
			modeStr := fOpenCfg.fileOpenModes[i].String()
			modeStr = strings.Replace(modeStr, "Mode", "", 1)
			sb.WriteString(fmt.Sprintf("%s", modeStr))
		}

	}

	return sb.String()
}

// IsValid - If the current FileOpenConfig instance is valid and properly
// initialized, this method returns nil. If the current FileOpenConfig
// instance is invalid, this method returns an error.
func (fOpenCfg *FileOpenConfig) IsValid() error {

	ePrefix := "FileOpenConfig.IsValid() "

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if !fOpenCfg.isInitialized {
		return errors.New(ePrefix +
			"Error: The current FileOpenConfig instance has NOT been " +
			"properly initialized.")
	}

	err := fOpenCfg.fileOpenType.IsValid()

	if err != nil {
		return fmt.Errorf(ePrefix+
			"Error: The File Open Type is INVALID!. %v", err.Error())
	}

	lenFileOpenModes := len(fOpenCfg.fileOpenModes)

	if fOpenCfg.fileOpenType == FOpenType.TypeNone() &&
		lenFileOpenModes > 1 {
		return errors.New(ePrefix +
			"Error: Current FileOpenConfig has Type='None' and " +
			"multiple File Open Modes!")
	}

	if fOpenCfg.fileOpenType == FOpenType.TypeNone() &&
		lenFileOpenModes == 1 &&
		fOpenCfg.fileOpenModes[0] != FileOpenMode(0).ModeNone() {
		return errors.New(ePrefix +
			"Error: Current FileOpenConfig has Type='None' and " +
			"a valid File Open Mode")
	}

	if fOpenCfg.fileOpenType != FOpenType.TypeNone() &&
		lenFileOpenModes > 1 {

		for i := 0; i < lenFileOpenModes; i++ {
			if fOpenCfg.fileOpenModes[i] == FileOpenMode(0).ModeNone() {
				return errors.New(ePrefix +
					"Error: The File Open Status has multiple File Open Modes " +
					"one of which is 'None'. Resolve this conflict.")
			}
		}

	}

	for i := 0; i < lenFileOpenModes; i++ {

		err := fOpenCfg.fileOpenModes[i].IsValid()

		if err != nil {
			return fmt.Errorf(ePrefix+
				"Error: A File Open Mode is INVALID! Index='%v' "+
				"Invalid Error='%v' ", i, err.Error())
		}

	}

	return nil
}

// New - Creates and returns a fully initialized FileOpenConfig instance which
// encapsulates a "File Open" parameter or code.
//
// To create a File Open parameter, two components are required:
//
//  1. A FileOpenType
//     AND
//
//  2. A FileOpenMode
//
//     FileOpenType: In order to open a file, exactly one of the
//     following File Open Codes MUST be specified:
//
//     FileOpenType(0).TypeReadOnly()
//     FileOpenType(0).TypeWriteOnly()
//     FileOpenType(0).TypeReadWrite()
//
//     FileOpenMode: In addition to a 'FileOpenType', a File Open Mode is also required.
//     Zero or more of the following File Open Mode codes may optionally
//     be specified to better control file open behavior.
//
//     FileOpenMode(0).ModeAppend()
//     FileOpenMode(0).ModeCreate()
//     FileOpenMode(0).ModeExclusive()
//     FileOpenMode(0).ModeSync()
//     FileOpenMode(0).ModeTruncate()
//
//     The composite file open code is created internally by or'ing together the FileOpenType
//     and FileOpenMode codes.
//
//     Reference CONSTANTS: https://golang.org/pkg/os/
//
// ------------------------------------------------------------------------
//
// Input Parameters:
//
//	fOpenType      FileOpenType - The FileOpenType used to open a file.
//
//	fOpenModes     FileOpenMode - Zero or more FileOpenMode instances which will be or'd
//	                              with the input parameter 'fOpenType' in order to generate
//	                              the composite 'file open' code which will be used to open
//	                              a file.  If no File Open Modes will be used, the user should
//	                              pass 'FileOpenMode(0).None()' or pass nothing for this
//	                              parameter.
//
// ------------------------------------------------------------------------
//
// Return Values:
//
//	FileOpenConfig - If successful, this method will return a new, fully initialized instance
//	                 of FileOpenConfig. The type 'FileOpenConfig' creates and encapsulates the
//	                 file open code required by low-level file open methods.
//
//
//	error          - If this method completes successfully, the returned error
//	                 Type is set equal to 'nil'. If an error condition is encountered,
//	                 this method will return an error Type which encapsulates an
//	                 appropriate error message.
func (fOpenCfg FileOpenConfig) New(fOpenType FileOpenType, fOpenModes ...FileOpenMode) (FileOpenConfig, error) {

	ePrefix := "FileOpenConfig.New() "

	err := fOpenType.IsValid()

	if err != nil {
		return FileOpenConfig{},
			fmt.Errorf(ePrefix+"Error: Input parameter 'fOpenType' is INVALID! fOpenType='%v' ", err.Error())
	}
	resultFOpenStatus := FileOpenConfig{}

	resultFOpenStatus.fileOpenType = fOpenType

	resultFOpenStatus.fileOpenModes = make([]FileOpenMode, 0)

	if len(fOpenModes) == 0 {

		resultFOpenStatus.fileOpenModes = append(resultFOpenStatus.fileOpenModes, FOpenMode.ModeNone())

		resultFOpenStatus.isInitialized = true

		return resultFOpenStatus, nil
	}

	for idx, mode := range fOpenModes {

		err = mode.IsValid()

		if err != nil {
			return FileOpenConfig{},
				fmt.Errorf(ePrefix+
					"Error: Input parameter 'fOpenModes' contains an invalid FileOpenMode. Index='%v' ", idx)
		}

		resultFOpenStatus.fileOpenModes = append(resultFOpenStatus.fileOpenModes, mode)

	}

	resultFOpenStatus.isInitialized = true

	return resultFOpenStatus, nil
}

// SetFileOpenType - Receives an input parameter 'fOpenType' which is
// used to set the internal stored FileOpenType for the current FileOpenConfig
// instance.
func (fOpenCfg *FileOpenConfig) SetFileOpenType(fOpenType FileOpenType) error {

	ePrefix := "FileOpenConfig.SetFileOpenType() "

	err := fOpenType.IsValid()

	if err != nil {
		return fmt.Errorf(ePrefix+"Input parameter 'fOpenType' is INVALID! fOpenType='%v' ",
			fOpenType.Value())
	}

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	if fOpenType == FileOpenType(0).TypeNone() {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
	}

	fOpenCfg.fileOpenType = fOpenType

	fOpenCfg.isInitialized = true

	return nil
}

// SetFileOpenModes - Receives a series of FileOpenMode instances and
// replaces the internal stored FileOpenMode values for this FileOpenConfig instance.
//
// To clear the current internal FileOpenMode values, pass nothing as an input parameter
// or pass the value FileOpenMode(0).None().
func (fOpenCfg *FileOpenConfig) SetFileOpenModes(fOpenModes ...FileOpenMode) error {

	ePrefix := "FileOpenConfig.SetFileOpenModes() "

	if fOpenCfg.fileOpenModes == nil {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	}

	lenFOpenModes := len(fOpenModes)

	if lenFOpenModes == 0 {
		fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
		fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
		return nil
	}

	fOpenCfg.fileOpenModes = make([]FileOpenMode, 0)
	var err error

	for idx, fOpenMode := range fOpenModes {

		err = fOpenMode.IsValid()

		if err != nil {
			fOpenCfg.fileOpenModes = make([]FileOpenMode, 1)
			fOpenCfg.fileOpenModes[0] = FOpenMode.ModeNone()
			return fmt.Errorf(ePrefix+"Error: File Open Mode INVALID! "+
				"index='%v' Error='%v' ", idx, err.Error())
		}

		fOpenCfg.fileOpenModes = append(fOpenCfg.fileOpenModes, fOpenMode)
	}

	err = fOpenCfg.fileOpenType.IsValid()

	if err == nil {
		fOpenCfg.isInitialized = true
	}

	return nil
}
